<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Main.rs - UI loop and event handling - Ratatui Book</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././mdbook-admonish.css">
        <link rel="stylesheet" href="../.././theme/catppuccin.css">
        <link rel="stylesheet" href="../.././theme/catppuccin-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Home</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../../tutorial/counter-app/index.html"><strong aria-hidden="true">3.</strong> Counter App - Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../tutorial/counter-app/single-function.html"><strong aria-hidden="true">3.1.</strong> Single Function</a></li><li class="chapter-item expanded "><a href="../../tutorial/counter-app/refactor.html"><strong aria-hidden="true">3.2.</strong> Refactor</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Layouts - Tutorial</div></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/index.html"><strong aria-hidden="true">5.</strong> JSON Editor - Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../tutorial/json-editor/app.html"><strong aria-hidden="true">5.1.</strong> App.rs - Holding application state</a></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/main.html" class="active"><strong aria-hidden="true">5.2.</strong> Main.rs - UI loop and event handling</a></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/ui.html"><strong aria-hidden="true">5.3.</strong> Ui.rs - Layouts, widgets, frames, oh my!</a></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/closing_thoughts.html"><strong aria-hidden="true">5.4.</strong> Conclusion</a></li></ol></li><li class="chapter-item expanded "><a href="../../concepts/index.html"><strong aria-hidden="true">6.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../concepts/rendering.html"><strong aria-hidden="true">6.1.</strong> Rendering</a></li><li class="chapter-item expanded "><a href="../../concepts/event_handling.html"><strong aria-hidden="true">6.2.</strong> Event Handling</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Best Practices</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Application Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.</strong> Design Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.7.</strong> Application State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.8.</strong> Event Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.9.</strong> Key Binding</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.10.</strong> Threading</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.11.</strong> Logging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.12.</strong> Configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.13.</strong> Backend Choice</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> How To</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../how-to/features.html"><strong aria-hidden="true">7.1.</strong> Enable Features</a></li><li class="chapter-item expanded "><a href="../../how-to/choose-a-backend.html"><strong aria-hidden="true">7.2.</strong> Choose a Backend</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Blocks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Displaying Text</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.1.</strong> Styling-Text</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.2.</strong> Paragraphs</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Layouts</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.1.</strong> Layout Constraints</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Layout Widgets</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.7.</strong> Create a Widget</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.8.</strong> Handle Panics</div></li></ol></li><li class="chapter-item expanded "><a href="../../faq.html"><strong aria-hidden="true">8.</strong> FAQ</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> References</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Crate Docs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Starter Template</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Third Party Crates</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Developer Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Ratatui</div></li><li class="chapter-item expanded "><a href="../../developer-guide/book.html"><strong aria-hidden="true">10.2.</strong> Ratatui Book</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ratatui Book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/ratatui-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/ratatui-book/edit/main/src/tutorial/json-editor/main.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mainrs"><a class="header" href="#mainrs">Main.rs</a></h1>
<p>The <code>main</code> file in many ratatui applications is simply a place to store the startup loop, and
occasionally event handling. (See more ways to handle events in
<a href="./../concepts/event_handling.html">Event Handling</a>)</p>
<p>In this application, we will be using our <code>main</code> function to run the startup steps, and start the
main loop. We will also put our main loop logic and event handling in this file.</p>
<h2 id="main"><a class="header" href="#main">Main</a></h2>
<p>In our main function, we will set up the terminal, create an application state and run our
application, and finally reset the terminal to the state we found it in.</p>
<h3 id="application-pre-run-steps"><a class="header" href="#application-pre-run-steps">Application pre-run steps</a></h3>
<p>Because a <code>ratatui</code> application takes the whole screen, and captures all of the keyboard input, we
need some boilerplate at the beginning of our <code>main</code> function.</p>
<pre><code class="language-rust no_run noplayground">use crossterm::event::EnableMouseCapture;
use crossterm::execute;
use crossterm::terminal::{enable_raw_mode, EnterAlternateScreen};
use std::io;</code></pre>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;</code></pre>
<p>You might notice that we are using <code>stderr</code> for our output. This is because we want to allow the
user to pipe their completed json to other programs like <code>ratatui-tutorial &gt; output.json</code>. To do
this, we are utilizing the fact that <code>stderr</code> is piped differently than <code>stdout</code>, and rendering out
project in <code>stderr</code>, and printout our completed json in <code>stdout</code>.</p>
<p>For more information, please read the
<a href="https://docs.rs/crossterm/latest/crossterm/">crossterm documentation</a></p>
<h3 id="state-creation-and-loop-starting"><a class="header" href="#state-creation-and-loop-starting">State creation, and loop starting</a></h3>
<p>Now that we have prepared the terminal for our application to run, it is time to actually run it.</p>
<p>First, we need to create an instance of our <code>ApplicationState</code> or <code>app</code>, to hold all of the
program’s state, and then we will call our function which handles the event and draw loop.</p>
<pre><code class="language-rust no_run noplayground">    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);
</code></pre>
<h3 id="application-post-run-steps"><a class="header" href="#application-post-run-steps">Application post-run steps</a></h3>
<p>Since our <code>ratatui</code> application has changed the state of the user’s terminal with our
<a href="#application-pre-run-steps">pre-run boilerplate</a>, we need to undo what have did, and put the
terminal back to the way we found it.</p>
<p>Most of these functions will simply be the inverse of what we have done above.</p>
<pre><code class="language-rust no_run noplayground">use crossterm::event::DisableMouseCapture;
use crossterm::terminal::{disable_raw_mode, LeaveAlternateScreen};</code></pre>
<pre><code class="language-rust no_run noplayground">    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;</code></pre>
<p>When an application exits without running this closing boilerplate, the terminal will act very
strange, and the user will usually have to end the terminal session and start a new on. Thus it is
important that we handle our error in such a way that we can call this last piece.</p>
<pre><code class="language-rust no_run noplayground">    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}</code></pre>
<p>The if statement at the end of boilerplate checks if the <code>run_app</code> function errored. If <code>run_app</code>
returned an <code>Ok</code> state. If it returned an <code>Ok</code> state, we need to check if we should print the json.</p>
<p>If we don’t call our print function before we call <code>execute!(LeaveAlternateScreen)</code>, our prints will
be rendered on an old screen and lost when we leave the alternate screen. (For more information on
how this works, read the
<a href="https://docs.rs/crossterm/latest/crossterm/terminal/struct.LeaveAlternateScreen.html">Crossterm documentation</a>)</p>
<p>So, altogether, our finished function should looks like this:</p>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);


    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}</code></pre>
<h2 id="run_app"><a class="header" href="#run_app">run_app</a></h2>
<p>In this function, we will start to do some actual logic.</p>
<h3 id="method-signature"><a class="header" href="#method-signature">Method signature</a></h3>
<p>Let’s start with the method signature:</p>
<pre><code class="language-rust no_run noplayground">fn run_app&lt;B: Backend&gt;(terminal: &amp;mut Terminal&lt;B&gt;, app: &amp;mut App) -&gt; io::Result&lt;bool&gt; {
...</code></pre>
<p>This method accepts an object of type <code>Terminal</code> which implements the <code>ratatui::backed::Backend</code>
trait. This included the three (four counting the <code>TestBackend</code>) officially supported backends
included in <code>ratatui</code>, but allows for 3rd party backends to be implemented. <code>run_app</code> also requires
a mutable borrow to an application state object, as defined in this project. Finally, the <code>run_app</code>
returns an <code>io::Result&lt;bool&gt;</code> that indicates if there was an io error with the <code>Err</code> state, and an
<code>Ok(true)</code> or <code>Ok(false)</code> that indicates if the program should print out the finished json.</p>
<h3 id="ui-loop"><a class="header" href="#ui-loop">UI Loop</a></h3>
<p>Because <code>ratatui</code> requires us to implement our own event/ui loop, we will simply use the following
code to update our main loop.</p>
<pre><code class="language-rust no_run noplayground">    loop {
        terminal.draw(|f| ui(f, app))?;</code></pre>
<p>Let’s unpack that <code>draw</code> call really quick. <code>terminal</code> is the <code>Terminal&lt;Backend&gt;</code> that we take as an
arguement, <code>draw</code> is the <code>ratatui</code> command to draw a <code>Frame</code> to the terminal (technically to the
<code>Terminal&lt;Backend&gt;</code>, but that only matters on the <code>TestBackend</code>). <code>|f| ui(f, &amp;app)</code> tells <code>draw</code>
that we want to take <code>f: &lt;Frame&gt;</code> and pass it to our function <code>ui</code>, and <code>ui</code> will return a drawable
frame. Notice that we also pass a immutable borrow of our application state to the <code>ui</code> function.
This will be important later.</p>
<h3 id="event-handling"><a class="header" href="#event-handling">Event handling</a></h3>
<p>Now that we have started our app, and have set up the ui rendering, we will implement the event
handling.</p>
<h4 id="polling"><a class="header" href="#polling">Polling</a></h4>
<p>Because we are using crossterm, we simply poll for keyboard events with</p>
<pre><code class="language-rust no_run noplayground">        if let Event::Key(key) = event::read()? {
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; match key.code {
                    KeyCode::Enter =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.currently_editing = Some(CurrentlyEditing::Value);
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.save_key_value();
                                    app.current_screen = CurrentScreen::Main;
                                }
                            }
                        }
                    }
                    KeyCode::Backspace =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.key_input.pop();
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.value_input.pop();
                                }
                            }
                        }
                    }
                    KeyCode::Esc =&gt; {
                        app.current_screen = CurrentScreen::Main;
                        app.currently_editing = None;
                    }
                    KeyCode::Tab =&gt; {
                        app.toggle_editing();
                    }
                    KeyCode::Char(value) =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.key_input.push(value);
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.value_input.push(value);
                                }
                            }
                        }
                    }
                    _ =&gt; {}
                },
                _ =&gt; {}
            }
        }</code></pre>
<p>and then match the results. Please note that the process for polling events will vary on the backend
you are utilizing, and you will need to refer to the documentation of that backend for more
information.</p>
<h4 id="main-screen"><a class="header" href="#main-screen">Main Screen</a></h4>
<p>We will start with the keybinds and event handling for the <code>CurrentScreen::Main</code>.</p>
<pre><code class="language-rust no_run noplayground">            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },</code></pre>
<p>After matching to the <code>Main</code> enum variant, we match the event. When the user is in the main screen,
there are only two keybinds, and the rest are ignored.</p>
<p>In this case, <code>KeyCode::Char('e')</code> changes the current screen to <code>CurrentScreen::Editing</code> and set
the <code>CurrentlyEditing</code> to a <code>Some</code> and notes that the user should be editing the <code>Key</code> value field,
as opposed to the <code>Value</code> field.</p>
<p><code>KeyCode::Char('q')</code> is straightforward, as it simply switches the application to the <code>Exiting</code>
screen, and allows the ui and future event handling runs to do the rest.</p>
<h4 id="exiting"><a class="header" href="#exiting">Exiting</a></h4>
<p>The next handler we will prepare, will handle events while the application is on the
<code>CurrentScreen::Exiting</code>. The job of this screen is to ask if the user wants to exit without
outputting the json. It is simply a <code>y/n</code> question, so that is all we listen for. We also add an
alternate exit key with <code>q</code>. If the user chooses to output the json, we return an <code>Ok(true)</code> that
indicates that our <code>main</code> function should call <code>app.print_json()</code> to perform the serialization and
printing for us after resetting the terminal to normal</p>
<pre><code class="language-rust no_run noplayground">                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },</code></pre>
<h4 id="editing"><a class="header" href="#editing">Editing</a></h4>
<p>Our final handler will be a bit more involved, as we will be changing the state of internal
variables.</p>
<p>We would like the <code>Enter</code> key to serve two purposes. When the user is editing the <code>Key</code>, we want the
enter key to switch the focus to editing the <code>Value</code>. However, if the <code>Value</code> is what is being
currently edited, <code>Enter</code> will save the key-value pair, and return to the <code>Main</code> screen.</p>
<pre><code class="language-rust no_run noplayground">                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; match key.code {
                    KeyCode::Enter =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.currently_editing = Some(CurrentlyEditing::Value);
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.save_key_value();
                                    app.current_screen = CurrentScreen::Main;
                                }
                            }
                        }
                    }</code></pre>
<p>When <code>Backspace</code> is pressed, we need to first determine if the user is editing a <code>Key</code> or a <code>Value</code>,
then <code>pop()</code> the endings of those strings accordingly.</p>
<pre><code class="language-rust no_run noplayground">                    KeyCode::Backspace =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.key_input.pop();
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.value_input.pop();
                                }
                            }
                        }
                    }</code></pre>
<p>When <code>Escape</code> is pressed, we want to quit editing.</p>
<pre><code class="language-rust no_run noplayground">                    KeyCode::Esc =&gt; {
                        app.current_screen = CurrentScreen::Main;
                        app.currently_editing = None;
                    }</code></pre>
<p>When <code>Tab</code> is pressed, we want the currently editing selection to switch.</p>
<pre><code class="language-rust no_run noplayground">                    KeyCode::Tab =&gt; {
                        app.toggle_editing();
                    }</code></pre>
<p>And finally, if the user types a valid character, we want to capture that, and add it to the string
that is the final key or value.</p>
<pre><code class="language-rust no_run noplayground">                    KeyCode::Char(value) =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.key_input.push(value);
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.value_input.push(value);
                                }
                            }
                        }
                    }</code></pre>
<p>Altogether, the event loop should look like this:</p>
<pre><code class="language-rust no_run noplayground">        if let Event::Key(key) = event::read()? {
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; match key.code {
                    KeyCode::Enter =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.currently_editing = Some(CurrentlyEditing::Value);
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.save_key_value();
                                    app.current_screen = CurrentScreen::Main;
                                }
                            }
                        }
                    }
                    KeyCode::Backspace =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.key_input.pop();
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.value_input.pop();
                                }
                            }
                        }
                    }
                    KeyCode::Esc =&gt; {
                        app.current_screen = CurrentScreen::Main;
                        app.currently_editing = None;
                    }
                    KeyCode::Tab =&gt; {
                        app.toggle_editing();
                    }
                    KeyCode::Char(value) =&gt; {
                        if let Some(editing) = &amp;app.currently_editing {
                            match editing {
                                CurrentlyEditing::Key =&gt; {
                                    app.key_input.push(value);
                                }
                                CurrentlyEditing::Value =&gt; {
                                    app.value_input.push(value);
                                }
                            }
                        }
                    }
                    _ =&gt; {}
                },
                _ =&gt; {}
            }
        }</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../tutorial/json-editor/app.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../tutorial/json-editor/ui.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../tutorial/json-editor/app.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../tutorial/json-editor/ui.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        <script type="text/javascript" src="../../mermaid-init.js"></script>


    </body>
</html>
