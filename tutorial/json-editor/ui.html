<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ui.rs - Layouts, widgets, frames, oh my! - Ratatui Book</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././mdbook-admonish.css">
        <link rel="stylesheet" href="../.././theme/catppuccin.css">
        <link rel="stylesheet" href="../.././theme/catppuccin-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Home</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../../tutorial/index.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li class="chapter-item expanded "><a href="../../tutorial/counter-app/index.html"><strong aria-hidden="true">4.</strong> Counter App</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../tutorial/counter-app/single-function.html"><strong aria-hidden="true">4.1.</strong> Single Function</a></li><li class="chapter-item expanded "><a href="../../tutorial/counter-app/refactor.html"><strong aria-hidden="true">4.2.</strong> Refactor</a></li></ol></li><li class="chapter-item expanded "><a href="../../concepts/index.html"><strong aria-hidden="true">5.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Rendering</div></li><li class="chapter-item expanded "><a href="../../concepts/event_handling.html"><strong aria-hidden="true">5.2.</strong> Event Handling</a></li></ol></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/index.html"><strong aria-hidden="true">6.</strong> JSON Editor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../tutorial/json-editor/app.html"><strong aria-hidden="true">6.1.</strong> App.rs - Holding application state</a></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/main.html"><strong aria-hidden="true">6.2.</strong> Main.rs - UI loop and event handling</a></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/ui.html" class="active"><strong aria-hidden="true">6.3.</strong> Ui.rs - Layouts, widgets, frames, oh my!</a></li><li class="chapter-item expanded "><a href="../../tutorial/json-editor/closing_thoughts.html"><strong aria-hidden="true">6.4.</strong> Conclusion</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> How To</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../how-to/features.html"><strong aria-hidden="true">7.1.</strong> Enable Features</a></li><li class="chapter-item expanded "><a href="../../how-to/choosing-a-backend.html"><strong aria-hidden="true">7.2.</strong> Choose a Backend</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Blocks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Displaying Text</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.1.</strong> Styling-Text</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.2.</strong> Paragraphs</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Layouts</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.1.</strong> Layout Constraints</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Layout Widgets</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.7.</strong> Create a Widget</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.8.</strong> Handle Panics</div></li></ol></li><li class="chapter-item expanded "><a href="../../faq.html"><strong aria-hidden="true">8.</strong> FAQ</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> References</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Crate Docs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Starter Template</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Third Party Crates</div></li></ol></li><li class="chapter-item expanded "><a href="../../concepts/index.html"><strong aria-hidden="true">10.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Best Practices</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> Application Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> Design Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.5.</strong> Application State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.6.</strong> Event Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.7.</strong> Key Binding</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.8.</strong> Threading</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.9.</strong> Logging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.10.</strong> Configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.11.</strong> Backend Choice</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Developer Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> Ratatui</div></li><li class="chapter-item expanded "><a href="../../developer-guide/book.html"><strong aria-hidden="true">11.2.</strong> Ratatui Book</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ratatui Book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/ratatui-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/ratatui-book/edit/main/src/tutorial/json-editor/ui.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="uirs"><a class="header" href="#uirs">UI.rs</a></h1>
<p>Finally we come to the last piece of the puzzle, and also the hardest part when you are just
starting out creating <code>ratatui</code> TUIs. The actual UI. If you have created a UI before, you should
know that the UI code can take up much more space than you think it should, and this is not
exception. We will only briefly cover layouts and how this core of <code>ratatui</code> design works, but there
will be links to more resources where they are covered in depth.</p>
<h2 id="some-basics"><a class="header" href="#some-basics">Some basics</a></h2>
<p>First, we need to understand how we draw widgets onto the screen in the first place. The TLDR is,
that we create a widget, and pass it to a <code>Frame</code> along with a size. How we get that size, is where
layouts come in.</p>
<pre><code class="language-rust no_run noplayground">    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Length(3),
                Constraint::Min(1),
                Constraint::Length(3),
            ]
            .as_ref(),
        )
        .split(f.size());</code></pre>
<p>You can this as an small instruction manual for cutting up a rectangle into smaller rectangles,
because that is what is actually happening. (Find more information on the different types of
constraints, read <a href="./../how-to/layout-constraints.html">How-To: Constraints</a>) In the example above,
you can read the instructions aloud like this: “Take the area f.size (which is a rectangle), and cut
it into three vertical pieces (making horizontal cuts). The first section should always be 3 lines
tall. The second section should never be smaller than one line tall, but can take extra space if
there is any. The final section should also be 3 lines tall”.</p>
<p>For those visual learners, I have the following graphic:</p>
<pre><code>This outer box is the original Frame,
which we get with frame.size()
------------------------------------ Constraint::Length(3)
|       This section should        |
|     always be 3 lines tall       |
|                                  |
|----------------------------------| Constraint::Min(1)
|      This section should         |
|     never be less than 1         |
|      line tall, but can be       |
|     longer if space is available |
|                                  |
------------------------------------ Constraint::Length(3)
|       This section should        |
|     always be 3 lines tall       |
|                                  |
|----------------------------------|
</code></pre>
<p>Now that we have that out of the way, let us create the TUI for our application.</p>
<h2 id="the-function-signature"><a class="header" href="#the-function-signature">The function signature</a></h2>
<p>Our ui function needs two things to successfully create our UI elements. The <code>Frame</code> which contains
the size of the terminal at render time (this is important, because it allows us to take resizeable
terminals into account), and the application state.</p>
<pre><code class="language-rust no_run noplayground">pub fn ui&lt;B: Backend&gt;(f: &amp;mut Frame&lt;B&gt;, app: &amp;App) {</code></pre>
<h1 id="the-main-screen"><a class="header" href="#the-main-screen">The Main screen</a></h1>
<p>Because we want the <code>Main</code> screen to be rendered behind the editing popup, we will draw it first,
and then have additional logic about our popups</p>
<h2 id="our-layout"><a class="header" href="#our-layout">Our layout</a></h2>
<p>Now that we have our <code>Frame</code>, we can actually begin drawing widgets onto it. We will begin by
creating out layout.</p>
<pre><code class="language-rust no_run noplayground">    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Length(3),
                Constraint::Min(1),
                Constraint::Length(3),
            ]
            .as_ref(),
        )
        .split(f.size());</code></pre>
<p>The variable <code>chunks</code> now contains a length 3 array of <code>Rect</code> objects that contain the top left
corner of their space, and their size. We will use these later, after we prepare our widgets.</p>
<h2 id="the-title"><a class="header" href="#the-title">The title</a></h2>
<p>The title is an important piece for any application. It helps the user understand what they can do
and where they are. To create our title, we are going to use a <code>Paragraph</code> widget (which is used to
display only text), and we are going to tell that <code>Paragraph</code> we want a border all around it by
giving it a <code>Block</code> with borders enabled. (See <a href="./../how-to/block.html">How-To: Block</a> and
<a href="./../how-to/paragraph.html">How-To: Paragraph</a> for more information about <code>Block</code> and <code>Paragraph</code>).</p>
<pre><code class="language-rust no_run noplayground">    let title_block = Block::default()
        .borders(Borders::ALL)
        .style(Style::default());

    let title = Paragraph::new(Text::styled(
        &quot;Create New Json&quot;,
        Style::default().fg(Color::Green),
    ))
    .block(title_block);

    f.render_widget(title, chunks[0]);</code></pre>
<p>In this code, the first thing we do, is create a <code>Block</code> with all borders enabled, and the default
style. Next, we created a paragraph widget with the text “Create New Json” styled green. (See
<a href="./../how-to/paragraph.html">How-To: Paragraphs</a> for more information about creating paragraphs and
<a href="./../how-to/styling-text.html">How-To: Styling-Text</a> for styling text) Finally, we call
<code>render_widget</code> on our <code>Frame</code>, and give it the widget we want to render it, and the <code>Rect</code>
representing where it needs to go and what size it should be. (this is the way all widgets are
drawn)</p>
<h2 id="the-list-of-existing-pairs"><a class="header" href="#the-list-of-existing-pairs">The list of existing pairs.</a></h2>
<p>We would also like the user to be able to see any key-value pairs that they have already entered.
For this, we will be using another widget, the <code>List</code>. The list is what it sounds like - it creates
a new line of text for each <code>ListItem</code>, and it supports passing in a state so you can implement
selecting items on the list with little extra work. We will not be implementing selection, as we
simply want the user to be able to see what they have already entered.</p>
<pre><code class="language-rust no_run noplayground">    let mut list_items = Vec::&lt;ListItem&gt;::new();

    for key in app.pairs.keys() {
        list_items.push(
            ListItem::new(
                Line::from(
                    Span::styled(
                        format!(&quot;{: &lt;25} : {}&quot;, key, app.pairs.get(key).unwrap()),
                        Style::default().fg(Color::Yellow),
                    )
                )
            )
        );
    }

    let list = List::new(list_items);

    f.render_widget(list, chunks[1]);</code></pre>
<p>For more information on Line, Span, and Style see
<a href="./../how-to/displaying-text.html">How-To: Displaying Text</a></p>
<p>In this piece of the function, we create a vector of <code>ListItem</code>s, and populate it with styled and
formatted key-value pairs. Finally, we create the <code>List</code> widget, and render it.</p>
<h2 id="the-bottom-navigational-bar"><a class="header" href="#the-bottom-navigational-bar">The bottom navigational bar</a></h2>
<p>It can help new users of your application, to see hints about what keys they can press. For this, we
are going to implement two bars, and another layout. These two bars will contain information on 1)
The current screen (<code>Main</code>, <code>Editing</code>, and <code>Exiting</code>), and 2) what keybinds are available.</p>
<p>Here, we will create a <code>Vec</code> of <code>Span</code> which will be converted later into a single line by the
<code>Paragraph</code>. (A <code>Span</code> is different from a <code>Line</code>, because a <code>Span</code> indicates a section of <code>Text</code>
with a style applied, and doesn’t end with a newline)</p>
<pre><code class="language-rust no_run noplayground">    let current_navigation_text = vec![
        // The first half of the text
        match app.current_screen {
            CurrentScreen::Main    =&gt; Span::styled(&quot;Normal Mode&quot;, Style::default().fg(Color::Green)),
            CurrentScreen::Editing =&gt; Span::styled(&quot;Editing Mode&quot;, Style::default().fg(Color::Yellow)),
            CurrentScreen::Exiting =&gt; Span::styled(&quot;Exiting&quot;, Style::default().fg(Color::LightRed)),
        }.to_owned(),
        // A white divider bar to separate the two sections
        Span::styled(&quot; | &quot;, Style::default().fg(Color::White)),
        // The final section of the text, with hints on what the user is editing
        {
            if let Some(editing) = &amp;app.currently_editing {
                match editing {
                    CurrentlyEditing::Key =&gt; Span::styled(&quot;Editing Json Key&quot;, Style::default().fg(Color::Green)),
                    CurrentlyEditing::Value =&gt; Span::styled(&quot;Editing Json Value&quot;, Style::default().fg(Color::LightGreen)),
                }
            } else {
                Span::styled(&quot;Not Editing Anything&quot;, Style::default().fg(Color::DarkGray))
            }
        },
    ];

    let mode_footer = Paragraph::new(Line::from(current_navigation_text))
        .block(Block::default().borders(Borders::ALL));</code></pre>
<p>Next, we are also going to make a hint in the navigation bar with available keys. This one does not
have several sections of text with different styles, and is thus less code.</p>
<pre><code class="language-rust no_run noplayground">    let current_keys_hint = {
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Editing =&gt; Span::styled(
                &quot;(ESC) to cancel/(Tab) to switch boxes/enter to complete&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Exiting =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
        }
    };

    let key_notes_footer =
        Paragraph::new(Line::from(current_keys_hint)).block(Block::default().borders(Borders::ALL));</code></pre>
<p>Finally, we are going to create our first nested layout. Because the <code>Layout.split</code> function
requires a <code>Rect</code>, and not a <code>Frame</code>, we can pass one of our chunks from the previous layout as the
space for the new layout. If you remember the bottom most section from the above graphic:</p>
<pre><code>------------------------------------ Constraint::Length(3)
|       This section should        |
|     always be 3 lines tall       |
|                                  |
|----------------------------------|
</code></pre>
<p>We will create a new layout in this space by passing it (<code>chunks[2]</code>) as the parameter for <code>split</code>.</p>
<pre><code class="language-rust no_run noplayground">    let footer_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)].as_ref())
        .split(chunks[2]);</code></pre>
<p>This code is the visual equivalent of this:</p>
<pre><code>----------------------------------- Constraint::Length(3)
|                |                |
| Percentage(50) | Percentage(50) |
|                |                |
|---------------------------------|
</code></pre>
<p>And now we can render our footer paragraphs in the appropriate spaces.</p>
<pre><code class="language-rust no_run noplayground">    f.render_widget(mode_footer, footer_chunks[0]);
    f.render_widget(key_notes_footer, footer_chunks[1]);</code></pre>
<h1 id="the-editing-popup"><a class="header" href="#the-editing-popup">The Editing Popup</a></h1>
<p>Now that the <code>Main</code> screen is rendered, we now need to check if the <code>Editing</code> popup needs to be
rendered. Since the <code>ratatui</code> renderer simply writes over the cells within a <code>Rect</code> on a
<code>render_widget</code>, we simply need to give <code>render_widget</code> an area on top of our <code>Main</code> screen to
create the appearance of a popup.</p>
<h2 id="popup-area-and-title"><a class="header" href="#popup-area-and-title">Popup area and title</a></h2>
<p>The first thing we will do, is draw the <code>Block</code> that will contain the popup. We will give this
<code>Block</code> a title to display as well to explain to the user what it is. (We will cover <code>centered_rect</code>
below)</p>
<pre><code class="language-rust no_run noplayground">    if let Some(editing) = &amp;app.currently_editing {
        let popup_block = Block::default()
            .title(&quot;Enter a new key-value pair&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let area = centered_rect(60, 25, f.size());
        f.render_widget(popup_block, area);</code></pre>
<h2 id="popup-contents"><a class="header" href="#popup-contents">Popup contents</a></h2>
<p>Now that we have where our popup is going to go, we can create the layout for the popup, and create
and draw the widgets inside of it.</p>
<p>First, we will create split the <code>Rect</code> given to us by <code>centered_rect</code>, and create a layout from it.
Note the use of <code>margin(1)</code>, which gives a 1 space margin around any layout block, meaning our new
blocks and widgets don’t overwrite anything from the first popup block.</p>
<pre><code class="language-rust no_run noplayground">        let popup_chunks = Layout::default()
            .direction(Direction::Horizontal)
            .margin(1)
            .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
            .split(area);</code></pre>
<p>Now that we have the layout for where we want to display the keys and values, we will actually
create the blocks and paragraphs to show what the user has already entered.</p>
<pre><code class="language-rust no_run noplayground">        let mut key_block = Block::default().title(&quot;Key&quot;).borders(Borders::ALL);
        let mut value_block = Block::default().title(&quot;Value&quot;).borders(Borders::ALL);

        let active_style = Style::default().bg(Color::LightYellow).fg(Color::Black);

        match editing {
            CurrentlyEditing::Key =&gt; key_block = key_block.style(active_style),
            CurrentlyEditing::Value =&gt; value_block = value_block.style(active_style),
        };

        let key_text = Paragraph::new(app.key_input.clone()).block(key_block);
        f.render_widget(key_text, popup_chunks[0]);

        let value_text = Paragraph::new(app.value_input.clone()).block(value_block);
        f.render_widget(value_text, popup_chunks[1]);</code></pre>
<p>Note that we are declaring the blocks as variables, and then adding extra styling to the block the
user is currently editing. Then we create the <code>Paragraph</code> widgets, and assign the blocks with those
variables. Also note how we used the <code>popup_chunks</code> layout instead of the <code>popup_block</code> layout to
render these widgets into.</p>
<h1 id="the-exit-popup"><a class="header" href="#the-exit-popup">The Exit Popup</a></h1>
<p>We have a way for the user to view their already entered key-value pairs, and we have a way for the
user to enter new ones. The last screen we need to create, is the exit/confirmation screen.</p>
<p>In this screen, we are asking the user if they want to output the key-value pairs they have entered
in the <code>stdout</code> pipe, or close without outputting anything.</p>
<pre><code class="language-rust no_run noplayground">    if let CurrentScreen::Exiting = app.current_screen {
        f.render_widget(Clear, f.size()); //this clears the entire screen and anything already drawn
        let popup_block = Block::default()
            .title(&quot;Y/N&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let exit_text = Text::styled(
            &quot;Would you like to output the buffer as json? (y/n)&quot;,
            Style::default().fg(Color::Red),
        );
        // the `trim: false` will stop the text from being cut off when over the edge of the block
        let exit_paragraph = Paragraph::new(exit_text)
            .block(popup_block)
            .wrap(Wrap { trim: false });

        let area = centered_rect(60, 25, f.size());
        f.render_widget(exit_paragraph, area);
    }</code></pre>
<p>The only thing in this part that we havn’t done before, is use the <code>Clear</code> widget. This is a special
widget that does what the name suggests - it clears everything in the space it is rendered. In this
case, it clears all of the menu that was pre-rendered behind it.</p>
<h1 id="helper-functions"><a class="header" href="#helper-functions">Helper Functions</a></h1>
<p>Finally, we will implement the <code>centered_rect</code> helper function that is referenced above. This code
is adapted from the
<a href="https://github.com/ratatui-org/ratatui/blob/main/examples/popup.rs">popup example</a> found in the
official repo.</p>
<pre><code class="language-rust no_run noplayground">/// helper function to create a centered rect using up certain percentage of the available rect `r`
fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -&gt; Rect {
    // Cut the given rectangle into three vertical pieces
    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Percentage((100 - percent_y) / 2),
                Constraint::Percentage(percent_y),
                Constraint::Percentage((100 - percent_y) / 2),
            ]
            .as_ref(),
        )
        .split(r);

    // Then cut the middle vertical piece into three width-wise pieces
    Layout::default()
        .direction(Direction::Horizontal)
        .constraints(
            [
                Constraint::Percentage((100 - percent_x) / 2),
                Constraint::Percentage(percent_x),
                Constraint::Percentage((100 - percent_x) / 2),
            ]
            .as_ref(),
        )
        .split(popup_layout[1])
        [1] // Return the middle chunk
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../tutorial/json-editor/main.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../tutorial/json-editor/closing_thoughts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../tutorial/json-editor/main.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../tutorial/json-editor/closing_thoughts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        <script type="text/javascript" src="../../mermaid-init.js"></script>


    </body>
</html>
