<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ratatui Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Home</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorial/hello-world/index.html"><strong aria-hidden="true">2.</strong> Hello World - Tutorial</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/index.html"><strong aria-hidden="true">3.</strong> Counter App - Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/counter-app/single-function.html"><strong aria-hidden="true">3.1.</strong> Single Function</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/refactor.html"><strong aria-hidden="true">3.2.</strong> Multiple Functions</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/multiple-files.html"><strong aria-hidden="true">3.3.</strong> Multiple Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/counter-app/app.html"><strong aria-hidden="true">3.3.1.</strong> app.rs</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/ui.html"><strong aria-hidden="true">3.3.2.</strong> ui.rs</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/event.html"><strong aria-hidden="true">3.3.3.</strong> event.rs</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/tui.html"><strong aria-hidden="true">3.3.4.</strong> tui.rs</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/handler.html"><strong aria-hidden="true">3.3.5.</strong> handler.rs</a></li><li class="chapter-item expanded "><a href="tutorial/counter-app/main.html"><strong aria-hidden="true">3.3.6.</strong> main.rs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tutorial/json-editor/index.html"><strong aria-hidden="true">4.</strong> JSON Editor - Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/json-editor/app.html"><strong aria-hidden="true">4.1.</strong> App.rs - Holding application state</a></li><li class="chapter-item expanded "><a href="tutorial/json-editor/main.html"><strong aria-hidden="true">4.2.</strong> Main.rs - UI loop and event handling</a></li><li class="chapter-item expanded "><a href="tutorial/json-editor/ui.html"><strong aria-hidden="true">4.3.</strong> Ui.rs - Layouts, widgets, frames, oh my!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/json-editor/ui-main.html"><strong aria-hidden="true">4.3.1.</strong> Ui.rs - Main</a></li><li class="chapter-item expanded "><a href="tutorial/json-editor/ui-editing.html"><strong aria-hidden="true">4.3.2.</strong> Ui.rs - Editing</a></li><li class="chapter-item expanded "><a href="tutorial/json-editor/ui-exit.html"><strong aria-hidden="true">4.3.3.</strong> Ui.rs - Exit</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/json-editor/closing_thoughts.html"><strong aria-hidden="true">4.4.</strong> Conclusion</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">5.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/rendering.html"><strong aria-hidden="true">5.1.</strong> Rendering</a></li><li class="chapter-item expanded "><a href="concepts/event_handling.html"><strong aria-hidden="true">5.2.</strong> Event Handling</a></li><li class="chapter-item expanded "><a href="concepts/the-elm-architecture.html"><strong aria-hidden="true">5.3.</strong> The Elm Architecture</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Application Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Design Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Application State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Event Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Key Binding</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Threading</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Logging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Configuration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> Backend Choice</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> How To</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="how-to/features.html"><strong aria-hidden="true">6.1.</strong> Enable Features</a></li><li class="chapter-item expanded "><a href="how-to/choose-a-backend.html"><strong aria-hidden="true">6.2.</strong> Choose a Backend</a></li><li class="chapter-item expanded "><a href="how-to/setup-panic-hooks.html"><strong aria-hidden="true">6.3.</strong> Setup Panic Hooks</a></li><li class="chapter-item expanded "><a href="how-to/setup-panic-hooks-better-panic.html"><strong aria-hidden="true">6.4.</strong> Setup Panic Hooks with better-panic</a></li><li class="chapter-item expanded "><a href="how-to/setup-logging-tracing.html"><strong aria-hidden="true">6.5.</strong> Setup Logging with tracing</a></li><li class="chapter-item expanded "><a href="how-to/handle-xdg-directories.html"><strong aria-hidden="true">6.6.</strong> Handle XDG Directories</a></li><li class="chapter-item expanded "><a href="how-to/clap.html"><strong aria-hidden="true">6.7.</strong> Handle CLI arguments</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.8.</strong> Blocks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.9.</strong> Displaying Text</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.9.1.</strong> Styling-Text</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.9.2.</strong> Paragraphs</div></li></ol></li><li class="chapter-item expanded "><a href="how-to/layout-constraints-basics.html"><strong aria-hidden="true">6.10.</strong> Layouts Constraints Basics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.11.</strong> Layout Widgets</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.12.</strong> Create a Widget</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.13.</strong> Handle Panics</div></li></ol></li><li class="chapter-item expanded "><a href="faq/index.html"><strong aria-hidden="true">7.</strong> FAQ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="faq/duplicate-key-events-windows.html"><strong aria-hidden="true">7.1.</strong> Duplicate key events on Windows</a></li><li class="chapter-item expanded "><a href="faq/tokio-async.html"><strong aria-hidden="true">7.2.</strong> tokio / async</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> References</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Crate Docs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Starter Template</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Third Party Crates</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Developer Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Ratatui</div></li><li class="chapter-item expanded "><a href="developer-guide/book.html"><strong aria-hidden="true">9.2.</strong> Ratatui Book</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ratatui Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/ratatui-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ratatui-book"><a class="header" href="#ratatui-book">Ratatui Book</a></h1>
<img align="right" src="https://avatars.githubusercontent.com/u/125200832?s=128&v=4" alt="ratatui logo">
<p>This is the documentation project for <a href="https://github.com/ratatui-org/ratatui"><code>ratatui</code></a>, a Rust
library to build rich terminal user interfaces and dashboards.</p>
<p><a href="./LICENSE"><img src="https://img.shields.io/crates/l/ratatui?style=for-the-badge" alt="License" /></a>
<a href="https://github.com/ratatui-org/ratatui-book/actions/workflows/mdbook.yml"><img src="https://img.shields.io/github/actions/workflow/status/ratatui-org/ratatui-book/mdbook.yml?label=Github%20Pages&amp;logo=github&amp;style=for-the-badge" alt="GitHub Workflow Status" /></a>
<a href="https://ratatui-org.github.io/ratatui-book/"><img src="https://img.shields.io/badge/Read-Documentation-blue?style=for-the-badge" alt="Read the documentation" /></a>
<a href="https://discord.gg/pMCEU9hNEj"><img src="https://img.shields.io/discord/1070692720437383208?label=discord&amp;logo=discord&amp;style=for-the-badge" alt="Discord" /></a></p>
<p>To read the book online, visit:</p>
<p><a href="https://ratatui-org.github.io/ratatui-book/">https://ratatui-org.github.io/ratatui-book/</a>.</p>
<p>To read this book locally, run the following:</p>
<pre><code class="language-shell">git clone -b gh-pages https://github.com/ratatui-org/ratatui-book
cd ratatui-book
python -m http.server # or your favorite way to serve local files
</code></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="index.html#admonition-note"></a></p>
</div>
<div>
<p>We want to hear your feedback and suggestions.</p>
<p>Feel free to give some suggestions on improving the book or documentation via
<a href="https://github.com/ratatui-org/ratatui-book/discussions">GitHub Discussions</a> or chat with us on
<a href="https://discord.com/channels/1070692720437383208/1115053951000268832">Discord</a>.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="https://user-images.githubusercontent.com/24392180/244943746-93ab0e38-93e0-4ae0-a31b-91ae6c393185.gif" alt="" /></p>
<p><code>ratatui</code> is based on the principle of immediate rendering with intermediate buffers. This means
that at each new frame you have to build all widgets that are supposed to be part of the UI. In
short, the <code>ratatui</code> library handles drawing to the terminal.</p>
<p>It is important to note that <code>ratatui</code>:</p>
<ul>
<li>does <em>not</em> handle keyboard input events</li>
<li>does <em>not</em> modify the state of your application</li>
<li>does <em>not</em> dicate how you want to structure your application</li>
</ul>
<p>The <code>ratatui</code> crate is a library and not a framework. And the <code>ratatui</code> library provides widgets
that allows a developer to imperatively declare what the view of your application should look like,
and then allows a developer to draw those widgets efficiently to the terminal.</p>
<p>For these reasons, <code>ratatui</code> can be highly flexible and customizable. And while this can be
empowering, it also does put the onus on developers using <code>ratatui</code> to understand how to best
architect their applications, to tailor the experience for users as they see fit.</p>
<h2 id="who-is-ratatui-for"><a class="header" href="#who-is-ratatui-for">Who is ratatui for?</a></h2>
<p><code>ratatui</code> is designed for developers and enthusiasts who:</p>
<ul>
<li>appreciate the retro aesthetic of the terminal,</li>
<li>want a lightweight alternative to graphical user interfaces (GUIs),</li>
<li>need applications that are to be deployed in constrained environments, like on servers with
limited resources, and</li>
<li>prefer to have full control over input and events, allowing for a more customized and tailored
user experience.</li>
</ul>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who is this book for?</a></h2>
<p>In this book, we will cover beginner guides to advanced patterns for developing terminal user
interfaces.</p>
<p>Those new to the world of TUIs will find this book a comprehensive guide, introducing the
foundational concepts and walking through common patterns of using <code>ratatui</code>. Additionally,
developers who have worked with TUIs will understand the nuances and benefits of using <code>ratatui</code>.</p>
<p>We hope that this book can be a journey into creating beautiful and functional terminal-based
applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Getting started with <code>ratatui</code> is straightforward — Add it to the project, and you are ready to
start creating beautiful TUIs.</p>
<p>In this section, we will build a “hello world” TUI application.</p>
<h3 id="install-rust"><a class="header" href="#install-rust">Install <code>Rust</code></a></h3>
<p>The first step is to install Rust.</p>
<p>Check
<a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Installation section of the official Rust Book</a>
for more information. Most people tend to use <code>rustup</code> to manage their installation.</p>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-tip"></a></p>
</div>
<div>
<p><code>rustup</code> installs The Rust Programming Language from the official release channels,
enabling you to easily switch between stable, beta, and nightly compilers and keep them updated.</p>
</div>
</div>
<p><code>rustup</code> will set you up with the latest stable version of <code>rust</code> as well as <code>cargo</code>. <code>cargo</code> is
Rust’s package manager, and it is what we will use to create a new project and add <code>ratatui</code> as a
dependency.</p>
<h3 id="create-a-hello-world-project"><a class="header" href="#create-a-hello-world-project">Create a “hello world” project</a></h3>
<p>To start with a new project, you can run the following:</p>
<pre><code class="language-console">cargo new hello-world-tui
cd hello-world-tui
</code></pre>
<p>This creates a new folder called <code>hello-world-tui</code> and changes the directory to that folder.</p>
<p><code>cargo new</code> will instantiate a “binary” project by default.</p>
<pre><code class="language-sh">$ tree .
.
├── Cargo.toml
└── src
   └── main.rs
</code></pre>
<div id="admonition-tip-1" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-tip-1"></a></p>
</div>
<div>
<p>It is always good idea to add a <code>LICENSE</code> and a <code>README.md</code> for your projects.</p>
</div>
</div>
<p>You can compile and execute a “binary” project by running <code>cargo run</code>:</p>
<pre><code class="language-sh">$ cargo run
   Compiling hello-world-tui v0.1.0 (/Users/USER/gitrepos/hello-world-tui)
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/hello-world-tui`
Hello, world!
</code></pre>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-warning"></a></p>
</div>
<div>
<p>By default <code>cargo run</code> compiles your program with no optimizations and with debug information.
If you want to run it in with more optimizations, you can run <code>cargo run --release</code>.</p>
<pre><code class="language-sh">cargo run --release
   Compiling hello-world-tui v0.1.0 (/Users/USER/gitrepos/hello-world-tui)
    Finished release [optimized] target(s) in 0.08s
     Running `target/release/hello-world-tui`
Hello, world!
</code></pre>
<p>For more information, check out <a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">the <code>cargo</code> section in the official rust
book</a>.</p>
</div>
</div>
<h3 id="install-ratatui"><a class="header" href="#install-ratatui">Install <code>ratatui</code></a></h3>
<p>Installing <code>ratatui</code> is as easy as running the following:</p>
<pre><code class="language-console">cargo add ratatui crossterm
</code></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-note"></a></p>
</div>
<div>
<p><code>ratatui</code> has to be combined with a terminal backend.
You can learn more about the different terminal backends in the <a href="tutorial/hello-world/./../../how-to/choose-a-backend.html">how to choose a
backend</a> section. For the examples in this book, we are going to use
<code>crossterm</code>.</p>
</div>
</div>
<p>Running the above command in your console will add the latest version of <code>ratatui</code> and <code>crossterm</code>
to your project.</p>
<div id="admonition-tip-2" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-tip-2"></a></p>
</div>
<div>
<p>If you are interested in adding a specific version, you can run the following:</p>
<pre><code class="language-console">cargo add ratatui --version 0.19.0
</code></pre>
</div>
</div>
<h3 id="srcmainrs"><a class="header" href="#srcmainrs"><code>src/main.rs</code></a></h3>
<p>Open <code>src/main.rs</code> in your favorite editor, and copy paste the following code to it:</p>
<pre><code class="language-rust no_run noplayground">use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;

  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  loop {
    terminal.draw(|f| {
      f.render_widget(Paragraph::new(&quot;Hello World! (press 'q' to quit)&quot;), f.size());
    })?;

    if crossterm::event::poll(std::time::Duration::from_millis(250))? {
      if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
        if key.code == crossterm::event::KeyCode::Char('q') {
          break;
        }
      }
    }
  }

  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?;

  Ok(())
}</code></pre>
<p>Make sure you save and exit the file! Now we are ready to run the TUI.</p>
<h3 id="running-the-tui"><a class="header" href="#running-the-tui">Running the TUI</a></h3>
<p>We can run our program with:</p>
<pre><code>cargo run
</code></pre>
<p>You should see a TUI app with <code>Hello World! (press 'q' to quit)</code> show up in your terminal as a TUI
app.</p>
<p><img src="https://user-images.githubusercontent.com/1813121/262363304-d601478e-2091-40ce-b96f-671e9bf8904b.gif" alt="" /></p>
<p>You can press <code>q</code> to exit and go back to your terminal as it was before.</p>
<p>Congratulations! 🎉</p>
<p>You have written a “hello world” terminal user interface with <code>ratatui</code>. We will learn more about
how <code>ratatui</code> works in the next sections.</p>
<div id="admonition-question" class="admonition question">
<div class="admonition-title">
<p>Question</p>
<p><a class="admonition-anchor-link" href="tutorial/hello-world/index.html#admonition-question"></a></p>
</div>
<div>
<p>Can you modify the example above to exit when pressing <code>q</code> and when pressing <code>Q</code>?</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter-app"><a class="header" href="#counter-app">Counter App</a></h1>
<p>In the previous section, we built a “hello world” TUI. In this tutorial, we’ll develop a simple
counter application.</p>
<p>For the app, we’ll need a <code>Paragraph</code> to display the counter. We’ll also want to increment or
decrement the counter when a key is pressed. Let’s increment and decrement the counter with <code>j</code> and
<code>k</code>.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>Go ahead and set up a new rust project with</p>
<pre><code class="language-sh">cargo init ratatui-counter-app
cd ratatui-counter-app
</code></pre>
<p>We are only going to use 3 dependencies in this tutorial:</p>
<pre><code class="language-sh">cargo add ratatui crossterm anyhow
</code></pre>
<p><code>anyhow</code> for easier error handling and is optional.</p>
<h2 id="filestructure"><a class="header" href="#filestructure">Filestructure</a></h2>
<p>We are going to start off with one file like so:</p>
<pre><code class="language-sh">tree .
├── Cargo.toml
├── LICENSE
└── src
   └── main.rs
</code></pre>
<p>and expand it out to multiple files like so:</p>
<pre><code class="language-sh">tree .
├── Cargo.toml
├── LICENSE
└── src
   ├── app.rs
   ├── event.rs
   ├── handler.rs
   ├── lib.rs
   ├── main.rs
   ├── tui.rs
   └── ui.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-function"><a class="header" href="#single-function">Single Function</a></h1>
<p>In this section, we’ll walk through building a simple counter application, allowing users to
increase or decrease a displayed number using keyboard input.</p>
<p>Here’s a first pass at a counter application in Rust using <code>ratatui</code> where all the code is in one
<code>main</code> function:</p>
<pre><code class="language-rust">use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
  // startup: Enable raw mode for the terminal, giving us fine control over user input
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;

  // Initialize the terminal backend using crossterm
  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // Define our counter variable
  // This is the state of our application
  let mut counter = 0;

  // Main application loop
  loop {
    // Render the UI
    terminal.draw(|f| {
      f.render_widget(Paragraph::new(format!(&quot;Counter: {counter}&quot;)), f.size());
    })?;

    // Check for user input every 250 milliseconds
    if crossterm::event::poll(std::time::Duration::from_millis(250))? {
      // If a key event occurs, handle it
      if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
        match key.code {
          crossterm::event::KeyCode::Char('j') =&gt; counter += 1,
          crossterm::event::KeyCode::Char('k') =&gt; counter -= 1,
          crossterm::event::KeyCode::Char('q') =&gt; break,
          _ =&gt; (),
        }
      }
    }
  }

  // shutdown down: reset terminal back to original state
  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?;

  Ok(())
}</code></pre>
<p>In the code above, it is useful to think about various parts of the code as separate pieces of the
puzzle. This is useful to help refactor and reorganize your code for larger applications.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>We start by importing necessary components from the <code>ratatui</code> library, which provides a number of
different widgets and utilities.</p>
<pre><code class="language-rust">use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};</code></pre>
<h2 id="start-up"><a class="header" href="#start-up">Start up</a></h2>
<p>Using <code>crossterm</code>, we can set the terminal to raw mode and enter an alternate screen.</p>
<pre><code class="language-rust">crossterm::terminal::enable_raw_mode()?;
crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;</code></pre>
<h2 id="initialize"><a class="header" href="#initialize">Initialize</a></h2>
<p>Again using <code>crossterm</code>, we can create an instance of terminal backend</p>
<pre><code class="language-rust">let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;</code></pre>
<h2 id="shut-down"><a class="header" href="#shut-down">Shut Down</a></h2>
<p>Terminal disables raw mode and exits the alternate screen for a clean exit, ensuring the terminal
returns to its original state</p>
<pre><code class="language-rust">crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
crossterm::terminal::disable_raw_mode()?;</code></pre>
<h2 id="app-state"><a class="header" href="#app-state">App state</a></h2>
<p>Our application has just one variable that tracks the “state”, i.e. the counter value.</p>
<pre><code class="language-rust">let mut counter = 0;</code></pre>
<h2 id="run-loop"><a class="header" href="#run-loop">Run loop</a></h2>
<p>Our application runs in a continuous loop, constantly checking for user input and updating the
state, which in turn updates the display on the next loop.</p>
<pre><code class="language-rust">  // Main application loop
  loop {
    // draw UI based on state
    // ...
    // Update state based on user input
    // ...
    // Break from loop based on user input and/or state
  }</code></pre>
<p>Every TUI with <code>ratatui</code> is bound to have (at least) one main application run loop like this.</p>
<h2 id="ui"><a class="header" href="#ui">UI</a></h2>
<p>The UI part of our code takes the state of the application, i.e. the value of <code>counter</code> and uses it
to render a widget, i.e. a <code>Paragraph</code> widget.</p>
<pre><code class="language-rust">    terminal.draw(|f| {
      f.render_widget(Paragraph::new(format!(&quot;Counter: {counter}&quot;)), f.size());
    })?;</code></pre>
<h2 id="user-input"><a class="header" href="#user-input">User Input</a></h2>
<p>Every 250 milliseconds, the application checks if the user has pressed a key:</p>
<ul>
<li><code>j</code> increases the counter</li>
<li><code>k</code> decreases the counter</li>
<li><code>q</code> exits the application</li>
</ul>
<pre><code class="language-rust">    if crossterm::event::poll(std::time::Duration::from_millis(250))? {
      // If a key event occurs, handle it
      if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
        match key.code {
          crossterm::event::KeyCode::Char('j') =&gt; counter += 1,
          crossterm::event::KeyCode::Char('k') =&gt; counter -= 1,
          crossterm::event::KeyCode::Char('q') =&gt; break,
          _ =&gt; (),
        }
      }
    }</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>By understanding the structure and components used in this simple counter application, you are set
up to explore crafting more intricate terminal-based interfaces using <code>ratatui</code>.</p>
<p>In the next section, we will explore a refactor of the above code to separate the various parts into
individual functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactor"><a class="header" href="#refactor">Refactor</a></h1>
<p>In this section, we will walk through the process of refactoring the application to set ourselves up
better for bigger projects. Not all of these changes are <code>ratatui</code> specific, and are generally good
coding practices to follow.</p>
<h2 id="organizing-imports"><a class="header" href="#organizing-imports">Organizing imports</a></h2>
<p>The first thing you might consider doing is reorganizing imports with qualified names.</p>
<pre><code class="language-rust">use crossterm::{
  event::{self, Event::Key, KeyCode::Char},
  execute,
  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};</code></pre>
<h2 id="typedefs-and-type-aliases"><a class="header" href="#typedefs-and-type-aliases">Typedefs and Type Aliases</a></h2>
<p>By defining custom types and aliases, we can simplify our code and make it more expressive.</p>
<pre><code class="language-rust">type Err = Box&lt;dyn std::error::Error&gt;;
type Result&lt;T&gt; = std::result::Result&lt;T, Err&gt;;
pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;</code></pre>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/refactor.html#admonition-tip"></a></p>
</div>
<div>
<p>If you use the popular <a href="https://docs.rs/anyhow/latest/anyhow/"><code>anyhow</code></a> crate,
then instead of these two lines:</p>
<pre><code class="language-rust">type Err = Box&lt;dyn std::error::Error&gt;;
type Result&lt;T&gt; = std::result::Result&lt;T, Err&gt;;</code></pre>
<p>you can simply import <code>anyhow::Result</code>:</p>
<pre><code class="language-rust">use anyhow::Result;</code></pre>
<p>You will need to run <code>cargo add anyhow</code> for this to work.</p>
</div>
</div>
<p><code>Frame</code> is a shorthand type to represent the frame we draw to when we render our application.</p>
<h2 id="app-struct"><a class="header" href="#app-struct"><code>App</code> struct</a></h2>
<p>By defining an <code>App</code> struct, we can encapsulate our application state and make it more structured.</p>
<pre><code class="language-rust">struct App {
  counter: i64,
  should_quit: bool,
}</code></pre>
<ul>
<li><code>counter</code> holds the current value of our counter.</li>
<li><code>should_quit</code> is a flag that indicates whether the application should exit its main loop.</li>
</ul>
<h2 id="breaking-up-main"><a class="header" href="#breaking-up-main">Breaking up <code>main()</code></a></h2>
<p>We can extract significant parts of the <code>main()</code> function into separate smaller functions, e.g.
<code>startup()</code>, <code>shutdown()</code>, <code>ui()</code>, <code>update()</code>, <code>run()</code>.</p>
<p><code>startup()</code> is responsible for initializing the terminal.</p>
<pre><code class="language-rust">fn startup() -&gt; Result&lt;()&gt; {
  enable_raw_mode()?;
  execute!(std::io::stderr(), EnterAlternateScreen)?;
  Ok(())
}</code></pre>
<p><code>shutdown()</code> cleans up the terminal.</p>
<pre><code class="language-rust">fn shutdown() -&gt; Result&lt;()&gt; {
  execute!(std::io::stderr(), LeaveAlternateScreen)?;
  disable_raw_mode()?;
  Ok(())
}</code></pre>
<p><code>ui()</code> handles rendering of our application state.</p>
<pre><code class="language-rust">fn ui(f: &amp;mut Frame&lt;'_&gt;, app: &amp;App) {
  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
}</code></pre>
<p><code>update()</code> processes user input and updates our application state.</p>
<pre><code class="language-rust">fn update(app: &amp;mut App) -&gt; Result&lt;()&gt; {
  if event::poll(std::time::Duration::from_millis(250))? {
    if let Key(key) = event::read()? {
      match key.code {
        Char('j') =&gt; app.counter += 1,
        Char('k') =&gt; app.counter -= 1,
        Char('q') =&gt; app.should_quit = true,
        _ =&gt; (),
      }
    }
  }
  Ok(())
}</code></pre>
<p>You’ll notice that in the <code>update()</code> function we make use of pattern matching for handling user
input. This is a powerful feature in rust; and enhances readability and provides a clear pattern for
how each input is processed.</p>
<p><code>run()</code> contains our main application loop.</p>
<pre><code class="language-rust">fn run() -&gt; Result&lt;()&gt; {
  // ratatui terminal
  let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // application state
  let mut app = App { counter: 0, should_quit: false };

  loop {
    // application render
    t.draw(|f| {
      ui(f, &amp;app);
    })?;

    // application update
    update(&amp;mut app)?;

    // application exit
    if app.should_quit {
      break;
    }
  }

  Ok(())
}</code></pre>
<p>Each function now has a specific task, making our main application logic more organized and easier
to follow.</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  startup()?;
  let status = run();
  shutdown()?;
  status?;
  Ok(())
}</code></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/refactor.html#admonition-note"></a></p>
</div>
<div>
<p>You may be wondering if we could have written the <code>main</code> function like so:</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  startup()?;
  run()?;
  shutdown()?;
  Ok(())
}</code></pre>
<p>This works fine during the happy path of a program.</p>
<p>However, if your <code>run()</code> function returns an error, the program will not call <code>shutdown()</code>.
And this can leave your terminal in a messed up
state for your users.</p>
<p>Instead, we should ensure that <code>shutdown()</code> is <em>always</em> called before the program exits.</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  startup()?;
  let result = run();
  shutdown()?;
  result?;
  Ok(())
}</code></pre>
<p>Here, we can get the result of <code>run()</code>, and call <code>shutdown()</code> first and then <code>unwrap()</code> on the result.
This will be a much better experience for users.</p>
<p>We will discuss in future sections how to handle the situation when your code unexpectedly panics.</p>
</div>
</div>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>By making our code more organized, modular, and readable, we not only make it easier for others to
understand and work with but also set the stage for future enhancements and extensions.</p>
<p>Here’s the full code for reference:</p>
<pre><code class="language-rust">use anyhow::Result;
use crossterm::{
  event::{self, Event::Key, KeyCode::Char},
  execute,
  terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

fn startup() -&gt; Result&lt;()&gt; {
  enable_raw_mode()?;
  execute!(std::io::stderr(), EnterAlternateScreen)?;
  Ok(())
}

fn shutdown() -&gt; Result&lt;()&gt; {
  execute!(std::io::stderr(), LeaveAlternateScreen)?;
  disable_raw_mode()?;
  Ok(())
}

// App state
struct App {
  counter: i64,
  should_quit: bool,
}

// App ui render function
fn ui(f: &amp;mut Frame&lt;'_&gt;, app: &amp;App) {
  f.render_widget(Paragraph::new(format!(&quot;Counter: {}&quot;, app.counter)), f.size());
}

// App update function
fn update(app: &amp;mut App) -&gt; Result&lt;()&gt; {
  if event::poll(std::time::Duration::from_millis(250))? {
    if let Key(key) = event::read()? {
      match key.code {
        Char('j') =&gt; app.counter += 1,
        Char('k') =&gt; app.counter -= 1,
        Char('q') =&gt; app.should_quit = true,
        _ =&gt; (),
      }
    }
  }
  Ok(())
}

fn run() -&gt; Result&lt;()&gt; {
  // ratatui terminal
  let mut t = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // application state
  let mut app = App { counter: 0, should_quit: false };

  loop {
    // application render
    t.draw(|f| {
      ui(f, &amp;app);
    })?;

    // application update
    update(&amp;mut app)?;

    // application exit
    if app.should_quit {
      break;
    }
  }

  Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
  // setup terminal
  startup()?;

  let result = run();

  // teardown terminal before unwrapping Result of app run
  shutdown()?;

  result?;

  Ok(())
}</code></pre>
<div id="admonition-question" class="admonition question">
<div class="admonition-title">
<p>Question</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/refactor.html#admonition-question"></a></p>
</div>
<div>
<p>What do you think happens if you modify the example above to change the polling to <code>0</code> milliseconds?</p>
<p>What would happen if you change the example to poll every 10 seconds?</p>
<p>Experiment with different “tick rates” and see how that affects the user experience.
Also, monitor your CPU usage when you do this experiment.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-files"><a class="header" href="#multiple-files">Multiple Files</a></h1>
<p>At the moment, we have everything in just one file. However, this can be impractical if we want to
expand our app further.</p>
<p>Let’s start by creating a number of different files to represent the various concepts we covered in
the previous section:</p>
<pre><code class="language-bash">$ tree .
├── Cargo.toml
├── LICENSE
└── src
   ├── app.rs
   ├── event.rs
   ├── handler.rs
   ├── lib.rs
   ├── main.rs
   ├── tui.rs
   └── ui.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apprs"><a class="header" href="#apprs">app.rs</a></h1>
<p>Let’s start with the same <code>struct</code> as we had before:</p>
<pre><code class="language-rust">/// Application.
#[derive(Debug, Default)]
pub struct App {
  /// should the application exit?
  pub should_quit: bool,
  /// counter
  pub counter: u8,
}</code></pre>
<p>We can add additional methods to this <code>Application</code> struct:</p>
<pre><code class="language-rust">impl App {
  /// Constructs a new instance of [`App`].
  pub fn new() -&gt; Self {
    Self::default()
  }

  /// Handles the tick event of the terminal.
  pub fn tick(&amp;self) {
  }

  /// Set running to false to quit the application.
  pub fn quit(&amp;mut self) {
    self.should_quit = true;
  }

  pub fn increment_counter(&amp;mut self) {
    if let Some(res) = self.counter.checked_add(1) {
      self.counter = res;
    }
  }

  pub fn decrement_counter(&amp;mut self) {
    if let Some(res) = self.counter.checked_sub(1) {
      self.counter = res;
    }
  }
}</code></pre>
<p>We use the principle of encapsulation to expose an interface to modify the state. In this particular
instance, it may seem like overkill but it is good practice nonetheless.</p>
<p>The practical advantage of this is that it makes the state changes easy to test.</p>
<pre><code class="language-rust">mod tests {
    #[test]
    fn test_app_increment_counter() {
        let mut app = App::default();
        app.increment_counter();
        assert_eq!(app.counter, 1);
    }

    #[test]
    fn test_app_decrement_counter() {
        let mut app = App::default();
        app.decrement_counter();
        assert_eq!(app.counter, 0);
    }
}</code></pre>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/app.html#admonition-tip"></a></p>
</div>
<div>
<p>You can test a single function by writing out fully qualified module path
to the test function, like so:</p>
<pre><code class="language-bash">cargo test -- app::tests::test_app_increment_counter --nocapture
</code></pre>
<p>Or even test all functions that start with <code>test_app_</code> by doing this:</p>
<pre><code class="language-bash">cargo test -- app::tests::test_app_ --nocapture
</code></pre>
<p>The <code>--nocapture</code> flag prints stdout stderr to the console, which can help debugging tests.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uirs"><a class="header" href="#uirs">ui.rs</a></h1>
<p>Previously we were rendering a <code>Paragraph</code> with no styling.</p>
<p>Let’s make some improvements:</p>
<ol>
<li>Add a <code>Block</code> with a rounded border and the title <code>&quot;Counter App&quot;</code>.</li>
<li>Make everything in the Paragraph have a foreground color of <code>Color::Yellow</code></li>
</ol>
<p>This is what our code will now look like:</p>
<pre><code class="language-rust">use tui::{
  layout::Alignment,
  style::{Color, Style},
  widgets::{Block, BorderType, Borders, Paragraph},
};

use crate::{app::App, tui::Frame};

pub fn render(app: &amp;mut App, f: &amp;mut Frame) {
  f.render_widget(
    Paragraph::new(format!(
      &quot;
        Press `Esc`, `Ctrl-C` or `q` to stop running.\n\
        Press `j` and `k` to increment and decrement the counter respectively.\n\
        Counter: {}
      &quot;,
      app.counter
    ))
    .block(
      Block::default()
        .title(&quot;Counter App&quot;)
        .title_alignment(Alignment::Center)
        .borders(Borders::ALL)
        .border_type(BorderType::Rounded),
    )
    .style(Style::default().fg(Color::Yellow))
    .alignment(Alignment::Center),
    f.size(),
  )
}</code></pre>
<p>When rendered, this is what the UI will look like:</p>
<p><img src="https://user-images.githubusercontent.com/1813121/263155937-d8a8b6f6-97f4-4839-b855-ffd0249c2ae0.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eventrs"><a class="header" href="#eventrs">event.rs</a></h1>
<p>We are going to introduce a new concept right now. The concept of an <code>EventHandler</code>.</p>
<p>Previously, we were polling for key inputs every 250 ms using crossterm as part of the <code>main</code> loop.
Instead, now we are going to start a thread in the background that does the same thing.</p>
<p>First, let’s create an <code>Event</code> enum to handle the different kinds of events that can occur:</p>
<pre><code class="language-rust">/// Terminal events.
#[derive(Clone, Copy, Debug)]
pub enum Event {
  /// Terminal tick.
  Tick,
  /// Key press.
  Key(KeyEvent),
  /// Mouse click/scroll.
  Mouse(MouseEvent),
  /// Terminal resize.
  Resize(u16, u16),
}</code></pre>
<p>Next, let’s create an <code>EventHandler</code> struct:</p>
<pre><code class="language-rust">use std::{sync::mpsc, thread};

/// Terminal event handler.
#[derive(Debug)]
pub struct EventHandler {
  /// Event sender channel.
  sender: mpsc::Sender&lt;Event&gt;,
  /// Event receiver channel.
  receiver: mpsc::Receiver&lt;Event&gt;,
  /// Event handler thread.
  handler: thread::JoinHandle&lt;()&gt;,
}</code></pre>
<p>We are using <a href="https://doc.rust-lang.org/std/sync/mpsc/"><code>std::sync::mpsc</code></a> which is a “Multiple
Producer Single Consumer” channel.</p>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/event.html#admonition-tip"></a></p>
</div>
<div>
<p>A channel is a thread-safe communication mechanism that allows data to be transmitted between
threads. Essentially, it’s a conduit where one or more threads (the producers) can send data, and
another thread (the consumer) can receive this data.</p>
</div>
</div>
<p>In Rust, channels are particularly useful for sending data between threads without the need for
locks or other synchronization mechanisms. The “Multiple Producer, Single Consumer” aspect of
<code>std::sync::mpsc</code> means that while multiple threads can send data into the channel, only a single
thread can retrieve and process this data, ensuring a clear and orderly flow of information.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorial/counter-app/event.html#admonition-note"></a></p>
</div>
<div>
<p>In the code in this section, we only need a “Single Producer, Single Consumer” but we are going to
use <code>mpsc</code> to set us up for the future.</p>
</div>
</div>
<p>Finally, here’s the code that starts a thread that polls for events from <code>crossterm</code> and maps it to
our <code>Event</code> enum.</p>
<pre><code class="language-rust">impl EventHandler {
  /// Constructs a new instance of [`EventHandler`].
  pub fn new(tick_rate: u64) -&gt; Self {
    let tick_rate = Duration::from_millis(tick_rate);
    let (sender, receiver) = mpsc::channel();
    let handler = {
      let sender = sender.clone();
      thread::spawn(move || {
        let mut last_tick = Instant::now();
        loop {
          let timeout = tick_rate.checked_sub(last_tick.elapsed()).unwrap_or(tick_rate);

          if event::poll(timeout).expect(&quot;no events available&quot;) {
            match event::read().expect(&quot;unable to read event&quot;) {
              CrosstermEvent::Key(e) =&gt; sender.send(Event::Key(e)),
              CrosstermEvent::Mouse(e) =&gt; sender.send(Event::Mouse(e)),
              CrosstermEvent::Resize(w, h) =&gt; sender.send(Event::Resize(w, h)),
              _ =&gt; unimplemented!(),
            }
            .expect(&quot;failed to send terminal event&quot;)
          }

          if last_tick.elapsed() &gt;= tick_rate {
            sender.send(Event::Tick).expect(&quot;failed to send tick event&quot;);
            last_tick = Instant::now();
          }
        }
      })
    };
    Self { sender, receiver, handler }
  }

  /// Receive the next event from the handler thread.
  ///
  /// This function will always block the current thread if
  /// there is no data available and it's possible for more data to be sent.
  pub fn next(&amp;self) -&gt; Result&lt;Event&gt; {
    Ok(self.receiver.recv()?)
  }
}</code></pre>
<p>At the beginning of our <code>EventHandler</code> <code>new</code> method, we create a channel using <code>mpsc::channel()</code>.</p>
<pre><code class="language-rust">let (sender, receiver) = mpsc::channel();</code></pre>
<p>This gives us a <code>sender</code> and <code>receiver</code> pair. The <code>sender</code> can be used to send events, while the
<code>receiver</code> can be used to receive them.</p>
<p>A new thread is spawned to handle events. This thread runs in the background and is responsible for
polling and sending events to our main application through the channel.</p>
<p>Within our background thread, we continuously poll for events with <code>event::poll(timeout)</code>. If an
event is available, it’s read and sent through the sender channel. The types of events we handle
include keypresses, mouse movements, screen resizing, and regular time ticks.</p>
<pre><code class="language-rust">if event::poll(timeout)? {
  match event::read()? {
    CrosstermEvent::Key(e) =&gt; sender.send(Event::Key(e))?,
    CrosstermEvent::Mouse(e) =&gt; sender.send(Event::Mouse(e))?,
    CrosstermEvent::Resize(w, h) =&gt; sender.send(Event::Resize(w, h))?,
    _ =&gt; unimplemented!(),
  }
}</code></pre>
<p>We expose the <code>receiver</code> channel as part of a <code>next()</code> method.</p>
<pre><code class="language-rust">  pub fn next(&amp;self) -&gt; Result&lt;Event&gt; {
    Ok(self.receiver.recv()?)
  }</code></pre>
<p>Calling <code>event_handler.next()</code> method will call <code>receiver.recv()</code> which will cause the thread to
block until the <code>receiver</code> gets a new event.</p>
<p>Finally, we update the <code>last_tick</code> value based on the time elapsed since the previous <code>Tick</code>. We
also send a <code>Event::Tick</code> on the channel during this.</p>
<pre><code class="language-rust">if last_tick.elapsed() &gt;= tick_rate {
    sender.send(Event::Tick).expect(&quot;failed to send tick event&quot;);
    last_tick = Instant::now();
}</code></pre>
<p>In summary, our <code>EventHandler</code> abstracts away the complexity of event polling and handling into a
dedicated background thread.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuirs"><a class="header" href="#tuirs">tui.rs</a></h1>
<p>Next, we can further abstract the terminal functionality from earlier into a <code>Tui</code> struct.</p>
<p>It provides a concise and efficient way to manage the terminal, handle events, and render content.
Let’s dive into its composition and functionality.</p>
<p>This introductory section includes the same imports and type definitions as before. We add an
additional type alias for <code>CrosstermTerminal</code>.</p>
<pre><code class="language-rust">use std::{io, panic};

use anyhow::Result;
use crossterm::{
  event::{DisableMouseCapture, EnableMouseCapture},
  terminal::{self, EnterAlternateScreen, LeaveAlternateScreen},
};

pub type Frame&lt;'a&gt; = tui::Frame&lt;'a, tui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;
pub type CrosstermTerminal = tui::Terminal&lt;tui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

use crate::{app::App, event::EventHandler, ui};</code></pre>
<p>The <code>Tui</code> struct can be defined with two primary fields:</p>
<ul>
<li><code>terminal</code>: This provides a direct interface to the terminal, allowing operations like drawing,
clearing the screen, and more.</li>
<li><code>events</code>: An event handler that we defined in the previous section, which would help in managing
terminal events like keystrokes, mouse movements, and other input events.</li>
</ul>
<pre><code class="language-rust">/// Representation of a terminal user interface.
///
/// It is responsible for setting up the terminal,
/// initializing the interface and handling the draw events.
pub struct Tui {
  /// Interface to the Terminal.
  terminal: CrosstermTerminal,
  /// Terminal event handler.
  pub events: EventHandler,
}</code></pre>
<p>With this <code>Tui</code> struct, we can add helper methods to handle modifying the terminal state. For
example, here’s the <code>init</code> method:</p>
<pre><code class="language-rust">  /// Initializes the terminal interface.
  ///
  /// It enables the raw mode and sets terminal properties.
  pub fn init(&amp;mut self) -&gt; Result&lt;()&gt; {
    terminal::enable_raw_mode()?;
    crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;

    // Define a custom panic hook to reset the terminal properties.
    // This way, you won't have your terminal messed up if an unexpected error happens.
    let panic_hook = panic::take_hook();
    panic::set_hook(Box::new(move |panic| {
      Self::reset().expect(&quot;failed to reset the terminal&quot;);
      panic_hook(panic);
    }));

    self.terminal.hide_cursor()?;
    self.terminal.clear()?;
    Ok(())
  }
</code></pre>
<p>This is essentially the same as the <code>startup</code> function from before. One important thing to note that
this function can be used to set a panic hook that calls the <code>reset()</code> method.</p>
<pre><code class="language-rust">  /// Resets the terminal interface.
  ///
  /// This function is also used for the panic hook to revert
  /// the terminal properties if unexpected errors occur.
  fn reset() -&gt; Result&lt;()&gt; {
    terminal::disable_raw_mode()?;
    crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;
    Ok(())
  }

  /// Exits the terminal interface.
  ///
  /// It disables the raw mode and reverts back the terminal properties.
  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
    Self::reset()?;
    self.terminal.show_cursor()?;
    Ok(())
  }</code></pre>
<p>With this panic hook, in the event of an unexpected error or panic, the terminal properties will be
reset, ensuring that the terminal doesn’t remain in a disrupted state.</p>
<p>Finally, we can set up the draw method:</p>
<pre><code class="language-rust">  /// [`Draw`] the terminal interface by [`rendering`] the widgets.
  ///
  /// [`Draw`]: tui::Terminal::draw
  /// [`rendering`]: crate::ui:render
  pub fn draw(&amp;mut self, app: &amp;mut App) -&gt; Result&lt;()&gt; {
    self.terminal.draw(|frame| ui::render(app, frame))?;
    Ok(())
  }
</code></pre>
<p>This draw method leverages the <code>ui::render</code> function from earlier in this section to transform the
state of our application into widgets that are then displayed on the terminal.</p>
<p>Here’s the full <code>tui.rs</code> file for your reference:</p>
<pre><code class="language-rust">
use std::{io, panic};

use anyhow::Result;
use crossterm::{
  event::{DisableMouseCapture, EnableMouseCapture},
  terminal::{self, EnterAlternateScreen, LeaveAlternateScreen},
};

pub type Frame&lt;'a&gt; = tui::Frame&lt;'a, tui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;
pub type CrosstermTerminal = tui::Terminal&lt;tui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

use crate::{app::App, event::EventHandler, ui};

/// Representation of a terminal user interface.
///
/// It is responsible for setting up the terminal,
/// initializing the interface and handling the draw events.
pub struct Tui {
  /// Interface to the Terminal.
  terminal: CrosstermTerminal,
  /// Terminal event handler.
  pub events: EventHandler,
}

impl Tui {
  /// Constructs a new instance of [`Tui`].
  pub fn new(terminal: CrosstermTerminal, events: EventHandler) -&gt; Self {
    Self { terminal, events }
  }

  /// Initializes the terminal interface.
  ///
  /// It enables the raw mode and sets terminal properties.
  pub fn init(&amp;mut self) -&gt; Result&lt;()&gt; {
    terminal::enable_raw_mode()?;
    crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;

    // Define a custom panic hook to reset the terminal properties.
    // This way, you won't have your terminal messed up if an unexpected error happens.
    let panic_hook = panic::take_hook();
    panic::set_hook(Box::new(move |panic| {
      Self::reset().expect(&quot;failed to reset the terminal&quot;);
      panic_hook(panic);
    }));

    self.terminal.hide_cursor()?;
    self.terminal.clear()?;
    Ok(())
  }


  /// [`Draw`] the terminal interface by [`rendering`] the widgets.
  ///
  /// [`Draw`]: tui::Terminal::draw
  /// [`rendering`]: crate::ui:render
  pub fn draw(&amp;mut self, app: &amp;mut App) -&gt; Result&lt;()&gt; {
    self.terminal.draw(|frame| ui::render(app, frame))?;
    Ok(())
  }


  /// Resets the terminal interface.
  ///
  /// This function is also used for the panic hook to revert
  /// the terminal properties if unexpected errors occur.
  fn reset() -&gt; Result&lt;()&gt; {
    terminal::disable_raw_mode()?;
    crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;
    Ok(())
  }

  /// Exits the terminal interface.
  ///
  /// It disables the raw mode and reverts back the terminal properties.
  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
    Self::reset()?;
    self.terminal.show_cursor()?;
    Ok(())
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handlerrs"><a class="header" href="#handlerrs">handler.rs</a></h1>
<p>Finally we have the <code>handler.rs</code> file. Here, the <code>handle_key_events</code> function takes in two
arguments:</p>
<ul>
<li><code>key_event</code>: This is an event provided by the <code>crossterm</code> crate, representing a key press from the
user.</li>
<li><code>app</code>: A mutable reference to our application’s state, represented by the <code>App</code> struct.</li>
</ul>
<pre><code class="language-rust">use anyhow::Result;
use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};

use crate::app::App;

/// Handles the key events and updates the state of [`App`].
pub fn handle_key_events(key_event: KeyEvent, app: &amp;mut App) -&gt; Result&lt;()&gt; {
  match key_event.code {
    // Exit application on `ESC` or `q`
    KeyCode::Esc | KeyCode::Char('q') =&gt; {
      app.quit();
    },
    // Exit application on `Ctrl-C`
    KeyCode::Char('c') | KeyCode::Char('C') =&gt; {
      if key_event.modifiers == KeyModifiers::CONTROL {
        app.quit();
      }
    },
    // Counter handlers
    KeyCode::Right | KeyCode::Char('j') =&gt; {
      app.increment_counter();
    },
    KeyCode::Left | KeyCode::Char('k') =&gt; {
      app.decrement_counter();
    },
    _ =&gt; {},
  }
  Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h1>
<p>Putting it all together, we have the <code>main.rs</code> function:</p>
<pre><code class="language-rust">use std::io;

use anyhow::Result;
use ratatui_book_tutorial_counter_app::{
  app::App,
  event::{Event, EventHandler},
  handler::handle_key_events,
  tui::Tui,
};
use tui::{backend::CrosstermBackend, Terminal};

fn main() -&gt; Result&lt;()&gt; {
  // Create an application.
  let mut app = App::new();

  // Initialize the terminal user interface.
  let backend = CrosstermBackend::new(io::stderr());
  let terminal = Terminal::new(backend)?;
  let events = EventHandler::new(250);
  let mut tui = Tui::new(terminal, events);
  tui.init()?;

  // Start the main loop.
  while !app.should_quit {
    // Render the user interface.
    tui.draw(&amp;mut app)?;
    // Handle events.
    match tui.events.next()? {
      Event::Tick =&gt; app.tick(),
      Event::Key(key_event) =&gt; handle_key_events(key_event, &amp;mut app)?,
      Event::Mouse(_) =&gt; {},
      Event::Resize(_, _) =&gt; {},
    }
  }

  // Exit the user interface.
  tui.exit()?;
  Ok(())
}</code></pre>
<p>Because we call <code>tui.events.next()</code> in a loop, it blocks until there’s an event generated. If
there’s a key press, the state updates and the UI is refreshed. If there’s no key press, a <code>Tick</code>
event is generated every 250 milliseconds, which causes the UI to be refreshed.</p>
<p>This is what it looks like in practice to:</p>
<ul>
<li>Run the TUI</li>
<li>Wait 2.5 seconds</li>
<li>Press <code>j</code> 5 times</li>
<li>Wait 2.5 seconds</li>
<li>Press <code>k</code> 5 times</li>
<li>Wait 2.5 seconds</li>
<li>Press <code>q</code></li>
</ul>
<!--

```
Set Shell zsh
Sleep 2.5s
Type "cargo run"
Enter
Sleep 5s
Type "jjjjj"
Sleep 500ms
Type "kkkkk"
Sleep 5s
Type "q"
Sleep 2.5s
```

-->
<p><img src="https://user-images.githubusercontent.com/1813121/263404720-41bd81a0-4eec-479c-9333-44363a183613.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-editor"><a class="header" href="#json-editor">JSON Editor</a></h1>
<p>Now that we have covered some of the basics of a “hello world” and “counter” app, we are ready to
build and manage something more involved.</p>
<p>In this tutorial, we will be creating an application that gives the user a simple interface to enter
key-value pairs, which will be converted and printed to <code>stdout</code> in json. The purpose of this
application will be to give the user an interface to create correct json, instead of having to worry
about commas and brackets themselves.</p>
<h2 id="initialization-1"><a class="header" href="#initialization-1">Initialization</a></h2>
<p>Go ahead and set up a new rust project with</p>
<pre><code class="language-sh">cargo init ratatui-json-editor
</code></pre>
<p>and put the following in the <code>Cargo.toml</code>:</p>
<pre><code>[dependencies]
crossterm = &quot;0.26.1&quot;
ratatui = &quot;0.22.0&quot;
serde = { version = &quot;1.0.181&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.104&quot;
</code></pre>
<p>or the latest version of these libraries.</p>
<h2 id="filestructure-1"><a class="header" href="#filestructure-1">Filestructure</a></h2>
<p>Now create two files inside of <code>src/</code> so it looks like this:</p>
<pre><code>src
├── main.rs
├── ui.rs
└── app.rs
</code></pre>
<p>This follows a common approach to small applications in <code>ratatui</code>, where we have a state file, a UI
file, and the main file to tie it all together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apprs-1"><a class="header" href="#apprs-1">App.rs</a></h1>
<p>As we saw in the previous section, a common model for smaller <code>ratatui</code> applications is to have one
application state struct called <code>App</code> or some variant of that name. We will be using this paradigm
in this application as well.</p>
<p>This struct will contain all of our “persistent” data and will be passed to any function that needs
to know the current state of the application.</p>
<!-- (Read [Application Pattern Concepts](../concepts/storing_state.md) to explore some other models) -->
<h2 id="application-modes"><a class="header" href="#application-modes">Application modes</a></h2>
<p>It is useful to think about the several “modes” that your application can be in. Thinking in “modes”
will make it easier to segregate everything from what window is getting drawn, to what keybinds to
listen for.</p>
<p>We will be using the application’s state to track two things:</p>
<ol>
<li>what screen the user is seeing,</li>
<li>which box should be highlighted, the “key” or “value” (this only applies when the user is editing
a key-value pair).</li>
</ol>
<h3 id="current-screen-enum"><a class="header" href="#current-screen-enum">Current Screen Enum</a></h3>
<p>In this tutorial application, we will have three “screens”:</p>
<ul>
<li><code>Main</code>: the main summary screen showing all past key-value pairs entered</li>
<li><code>Editing</code>: the screen shown when the user wishes to create a new key-value pair</li>
<li><code>Exiting</code>: displays a prompt asking if the user wants to output the key-value pairs they have
entered.</li>
</ul>
<p>We represent these possible modes with a simple enum:</p>
<pre><code class="language-rust no_run noplayground">pub enum CurrentScreen {
    Main,
    Editing,
    Exiting,
}</code></pre>
<h3 id="currently-editing-enum"><a class="header" href="#currently-editing-enum">Currently Editing Enum</a></h3>
<p>As you may already know, <code>ratatui</code> does not automatically redraw the screen<sup class="footnote-reference"><a href="#note">1</a></sup>. <code>ratatui</code> also
does not remember anything about what it drew last frame.</p>
<p>This means that the programmer is responsible for handling all state and updating widgets to reflect
changes. In this case, we will allow the user to input two strings in the <code>Editing</code> mode - a key and
a value. The programmer is responsible for knowing which the user is trying to edit.</p>
<p>For this purpose, we will create another enum for our application state called <code>CurrentlyEditing</code> to
keep track of which field the user is currently entering:</p>
<pre><code class="language-rust no_run noplayground">pub enum CurrentlyEditing {
    Key,
    Value,
}</code></pre>
<h2 id="the-full-application-state"><a class="header" href="#the-full-application-state">The full application state</a></h2>
<p>Now that we have enums to help us track where the user is, we will create the struct that actually
stores this data which can be passed around where it is needed.</p>
<pre><code class="language-rust no_run noplayground">pub struct App {
    pub key_input: String,              // the currently being edited json key.
    pub value_input: String,            // the currently being edited json value.
    pub pairs: HashMap&lt;String, String&gt;, // The representation of our key and value pairs with serde Serialize support
    pub current_screen: CurrentScreen, // the current screen the user is looking at, and will later determine what is rendered.
    pub currently_editing: Option&lt;CurrentlyEditing&gt;, // the optional state containing which of the key or value pair the user is editing. It is an option, because when the user is not directly editing a key-value pair, this will be set to `None`.
}</code></pre>
<h2 id="helper-functions"><a class="header" href="#helper-functions">Helper functions</a></h2>
<p>While we could simply keep our application state as simply a holder of values, we can also create a
few helper functions which will make our life easier elsewhere. Of course, these functions should
only affect the application state itself, and nothing outside of it.</p>
<h4 id="new"><a class="header" href="#new"><code>new()</code></a></h4>
<p>We will be adding this function simply to make creating the state easier. While this could be
avoided by specifying it all in the instantiation of the variable, doing it here allows for easy to
change universal defaults for the state.</p>
<pre><code class="language-rust no_run noplayground">impl App {
    pub fn new() -&gt; App {
        App {
            key_input: String::new(),
            value_input: String::new(),
            pairs: HashMap::new(),
            current_screen: CurrentScreen::Main,
            currently_editing: None,
        }
    }
    ...</code></pre>
<h4 id="save_key_value"><a class="header" href="#save_key_value"><code>save_key_value()</code></a></h4>
<p>This function will be called when the user saves a key-value pair in the editor. It adds the two
stored variables to the key-value pairs <code>HashMap</code>, and resets the status of all of the editing
variables.</p>
<pre><code class="language-rust no_run noplayground">    ...
    pub fn save_key_value(&amp;mut self) {
        self.pairs
            .insert(self.key_input.clone(), self.value_input.clone());

        self.key_input = String::new();
        self.value_input = String::new();
        self.currently_editing = None;
    }
    ...</code></pre>
<h4 id="toggle_editing"><a class="header" href="#toggle_editing"><code>toggle_editing()</code></a></h4>
<p>Sometimes it is easier to put simple logic into a convenience function so we don’t have to worry
about it in the main code block. <code>toggle_editing</code> is one of those cases. All we are doing, is
checking if something is currently being edited, and if it is, swapping between editing the Key and
Value fields.</p>
<pre><code class="language-rust no_run noplayground">    ...
    pub fn toggle_editing(&amp;mut self) {
        if let Some(edit_mode) = &amp;self.currently_editing {
            match edit_mode {
                CurrentlyEditing::Key =&gt; self.currently_editing = Some(CurrentlyEditing::Value),
                CurrentlyEditing::Value =&gt; self.currently_editing = Some(CurrentlyEditing::Key),
            };
        } else {
            self.currently_editing = Some(CurrentlyEditing::Key);
        }
    }
    ...</code></pre>
<h4 id="print_json"><a class="header" href="#print_json"><code>print_json()</code></a></h4>
<p>Finally, is another convenience function to print out the serialized json from all of our key-value
pairs.</p>
<pre><code class="language-rust no_run noplayground">    ...
    pub fn print_json(&amp;self) -&gt; Result&lt;()&gt; {
        let output = serde_json::to_string(&amp;self.pairs)?;
        println!(&quot;{}&quot;, output);
        Ok(())
    }
    ...</code></pre>
<!-- prettier-ignore -->
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>In ratatui, every frame draws the UI anew. See the <a href="tutorial/json-editor/./../../concepts/rendering.html">Rendering section</a> for more information.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mainrs-1"><a class="header" href="#mainrs-1">Main.rs</a></h1>
<p>The <code>main</code> file in many ratatui applications is simply a place to store the startup loop, and
occasionally event handling. (See more ways to handle events in
<a href="tutorial/json-editor/./../concepts/event_handling.html">Event Handling</a>)</p>
<p>In this application, we will be using our <code>main</code> function to run the startup steps, and start the
main loop. We will also put our main loop logic and event handling in this file.</p>
<h2 id="main"><a class="header" href="#main">Main</a></h2>
<p>In our main function, we will set up the terminal, create an application state and run our
application, and finally reset the terminal to the state we found it in.</p>
<h3 id="application-pre-run-steps"><a class="header" href="#application-pre-run-steps">Application pre-run steps</a></h3>
<p>Because a <code>ratatui</code> application takes the whole screen, and captures all of the keyboard input, we
need some boilerplate at the beginning of our <code>main</code> function.</p>
<pre><code class="language-rust no_run noplayground">use crossterm::event::EnableMouseCapture;
use crossterm::execute;
use crossterm::terminal::{enable_raw_mode, EnterAlternateScreen};
use std::io;</code></pre>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;
    ...</code></pre>
<p>You might notice that we are using <code>stderr</code> for our output. This is because we want to allow the
user to pipe their completed json to other programs like <code>ratatui-tutorial &gt; output.json</code>. To do
this, we are utilizing the fact that <code>stderr</code> is piped differently than <code>stdout</code>, and rendering out
project in <code>stderr</code>, and printout our completed json in <code>stdout</code>.</p>
<p>For more information, please read the
<a href="https://docs.rs/crossterm/latest/crossterm/">crossterm documentation</a></p>
<h3 id="state-creation-and-loop-starting"><a class="header" href="#state-creation-and-loop-starting">State creation, and loop starting</a></h3>
<p>Now that we have prepared the terminal for our application to run, it is time to actually run it.</p>
<p>First, we need to create an instance of our <code>ApplicationState</code> or <code>app</code>, to hold all of the
program’s state, and then we will call our function which handles the event and draw loop.</p>
<pre><code class="language-rust no_run noplayground">    ...
    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);

    ...</code></pre>
<h3 id="application-post-run-steps"><a class="header" href="#application-post-run-steps">Application post-run steps</a></h3>
<p>Since our <code>ratatui</code> application has changed the state of the user’s terminal with our
<a href="tutorial/json-editor/main.html#application-pre-run-steps">pre-run boilerplate</a>, we need to undo what have did, and put the
terminal back to the way we found it.</p>
<p>Most of these functions will simply be the inverse of what we have done above.</p>
<pre><code class="language-rust no_run noplayground">use crossterm::event::DisableMouseCapture;
use crossterm::terminal::{disable_raw_mode, LeaveAlternateScreen};</code></pre>
<pre><code class="language-rust no_run noplayground">    ...
    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;
    ...</code></pre>
<p>When an application exits without running this closing boilerplate, the terminal will act very
strange, and the user will usually have to end the terminal session and start a new on. Thus it is
important that we handle our error in such a way that we can call this last piece.</p>
<pre><code class="language-rust no_run noplayground">    ...
    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}</code></pre>
<p>The if statement at the end of boilerplate checks if the <code>run_app</code> function errored. If <code>run_app</code>
returned an <code>Ok</code> state. If it returned an <code>Ok</code> state, we need to check if we should print the json.</p>
<p>If we don’t call our print function before we call <code>execute!(LeaveAlternateScreen)</code>, our prints will
be rendered on an old screen and lost when we leave the alternate screen. (For more information on
how this works, read the
<a href="https://docs.rs/crossterm/latest/crossterm/terminal/struct.LeaveAlternateScreen.html">Crossterm documentation</a>)</p>
<p>So, altogether, our finished function should looks like this:</p>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);


    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}</code></pre>
<h2 id="run_app"><a class="header" href="#run_app"><code>run_app</code></a></h2>
<p>In this function, we will start to do the actual logic.</p>
<h3 id="method-signature"><a class="header" href="#method-signature">Method signature</a></h3>
<p>Let’s start with the method signature:</p>
<pre><code class="language-rust no_run noplayground">fn run_app&lt;B: Backend&gt;(terminal: &amp;mut Terminal&lt;B&gt;, app: &amp;mut App) -&gt; io::Result&lt;bool&gt; {
...</code></pre>
<p>You’ll notice that we make this function generic across the <code>ratatui::backend::Backend</code>. In previous
sections we hardcoded the <code>CrosstermBackend</code>. This this trait approach allows us to make our code
backend agnostic.</p>
<p>This method accepts an object of type <code>Terminal</code> which implements the <code>ratatui::backend::Backend</code>
trait. This trait includes the three (four counting the <code>TestBackend</code>) officially supported backends
included in <code>ratatui</code>. It allows for 3rd party backends to be implemented.</p>
<p><code>run_app</code> also requires a mutable borrow to an application state object, as defined in this project.</p>
<p>Finally, the <code>run_app</code> returns an <code>io::Result&lt;bool&gt;</code> that indicates if there was an io error with
the <code>Err</code> state, and an <code>Ok(true)</code> or <code>Ok(false)</code> that indicates if the program should print out the
finished json.</p>
<h3 id="ui-loop"><a class="header" href="#ui-loop">UI Loop</a></h3>
<p>Because <code>ratatui</code> requires us to implement our own event/ui loop, we will simply use the following
code to update our main loop.</p>
<pre><code class="language-rust no_run noplayground">    ...
    loop {
        terminal.draw(|f| ui(f, app))?;
        ...</code></pre>
<p>Let’s unpack that <code>draw</code> call really quick.</p>
<ul>
<li><code>terminal</code> is the <code>Terminal&lt;Backend&gt;</code> that we take as an argument,</li>
<li><code>draw</code> is the <code>ratatui</code> command to draw a <code>Frame</code> to the terminal<sup class="footnote-reference"><a href="#note">1</a></sup>.</li>
<li><code>|f| ui(f, &amp;app)</code> tells <code>draw</code> that we want to take <code>f: &lt;Frame&gt;</code> and pass it to our function <code>ui</code>,
and <code>ui</code> will draw to that <code>Frame</code>.</li>
</ul>
<!-- prettier-ignore -->
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>Technically this is the command to to the <code>Terminal&lt;Backend&gt;</code>, but that only matters on the <code>TestBackend</code>.</p>
</div>
<p>Notice that we also pass a immutable borrow of our application state to the <code>ui</code> function. This will
be important later.</p>
<h3 id="event-handling"><a class="header" href="#event-handling">Event handling</a></h3>
<p>Now that we have started our app , and have set up the UI rendering, we will implement the event
handling.</p>
<h4 id="polling"><a class="header" href="#polling">Polling</a></h4>
<p>Because we are using <code>crossterm</code>, we can simply poll for keyboard events with</p>
<pre><code class="language-rust">if let Event::Key(key) = event::read()? {
    dbg!(key.code)
}</code></pre>
<p>and then match the results.</p>
<p>Alternatively, we can set up a thread to run in the background to poll and send <code>Event</code>s (as we did
in the “counter” tutorial). Let’s keep things simple here for the sake of illustration.</p>
<p>Note that the process for polling events will vary on the backend you are utilizing, and you will
need to refer to the documentation of that backend for more information.</p>
<h4 id="main-screen"><a class="header" href="#main-screen">Main Screen</a></h4>
<p>We will start with the keybinds and event handling for the <code>CurrentScreen::Main</code>.</p>
<pre><code class="language-rust no_run noplayground">        ...
        if let Event::Key(key) = event::read()? {
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                ...</code></pre>
<p>After matching to the <code>Main</code> enum variant, we match the event. When the user is in the main screen,
there are only two keybinds, and the rest are ignored.</p>
<p>In this case, <code>KeyCode::Char('e')</code> changes the current screen to <code>CurrentScreen::Editing</code> and set
the <code>CurrentlyEditing</code> to a <code>Some</code> and notes that the user should be editing the <code>Key</code> value field,
as opposed to the <code>Value</code> field.</p>
<p><code>KeyCode::Char('q')</code> is straightforward, as it simply switches the application to the <code>Exiting</code>
screen, and allows the ui and future event handling runs to do the rest.</p>
<h4 id="exiting"><a class="header" href="#exiting">Exiting</a></h4>
<p>The next handler we will prepare, will handle events while the application is on the
<code>CurrentScreen::Exiting</code>. The job of this screen is to ask if the user wants to exit without
outputting the json. It is simply a <code>y/n</code> question, so that is all we listen for. We also add an
alternate exit key with <code>q</code>. If the user chooses to output the json, we return an <code>Ok(true)</code> that
indicates that our <code>main</code> function should call <code>app.print_json()</code> to perform the serialization and
printing for us after resetting the terminal to normal</p>
<pre><code class="language-rust no_run noplayground">                ...
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                ...</code></pre>
<h4 id="editing"><a class="header" href="#editing">Editing</a></h4>
<p>Our final handler will be a bit more involved, as we will be changing the state of internal
variables.</p>
<p>We would like the <code>Enter</code> key to serve two purposes. When the user is editing the <code>Key</code>, we want the
enter key to switch the focus to editing the <code>Value</code>. However, if the <code>Value</code> is what is being
currently edited, <code>Enter</code> will save the key-value pair, and return to the <code>Main</code> screen.</p>
<pre><code class="language-rust no_run noplayground">                ...
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; {
                    match key.code {
                        KeyCode::Enter =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.currently_editing = Some(CurrentlyEditing::Value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.save_key_value();
                                        app.current_screen = CurrentScreen::Main;
                                    }
                                }
                            }
                        }
                        ...</code></pre>
<p>When <code>Backspace</code> is pressed, we need to first determine if the user is editing a <code>Key</code> or a <code>Value</code>,
then <code>pop()</code> the endings of those strings accordingly.</p>
<pre><code class="language-rust no_run noplayground">                        ...
                        KeyCode::Backspace =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.pop();
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.pop();
                                    }
                                }
                            }
                        }
                        ...</code></pre>
<p>When <code>Escape</code> is pressed, we want to quit editing.</p>
<pre><code class="language-rust no_run noplayground">                        ...
                        KeyCode::Esc =&gt; {
                            app.current_screen = CurrentScreen::Main;
                            app.currently_editing = None;
                        }
                        ...</code></pre>
<p>When <code>Tab</code> is pressed, we want the currently editing selection to switch.</p>
<pre><code class="language-rust no_run noplayground">                        ...
                        KeyCode::Tab =&gt; {
                            app.toggle_editing();
                        }
                        ...</code></pre>
<p>And finally, if the user types a valid character, we want to capture that, and add it to the string
that is the final key or value.</p>
<pre><code class="language-rust no_run noplayground">                        ...
                        KeyCode::Char(value) =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.push(value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.push(value);
                                    }
                                }
                            }
                        }
                        ...</code></pre>
<p>Altogether, the event loop should look like this:</p>
<pre><code class="language-rust no_run noplayground">        ...
        if let Event::Key(key) = event::read()? {
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; {
                    match key.code {
                        KeyCode::Enter =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.currently_editing = Some(CurrentlyEditing::Value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.save_key_value();
                                        app.current_screen = CurrentScreen::Main;
                                    }
                                }
                            }
                        }
                        KeyCode::Backspace =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.pop();
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.pop();
                                    }
                                }
                            }
                        }
                        KeyCode::Esc =&gt; {
                            app.current_screen = CurrentScreen::Main;
                            app.currently_editing = None;
                        }
                        KeyCode::Tab =&gt; {
                            app.toggle_editing();
                        }
                        KeyCode::Char(value) =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.push(value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.push(value);
                                    }
                                }
                            }
                        }
                        _ =&gt; {}
                    }
                }
                _ =&gt; {}
            }
        }
        ...</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uirs-1"><a class="header" href="#uirs-1">UI.rs</a></h1>
<p>Finally we come to the last piece of the puzzle, and also the hardest part when you are just
starting out creating <code>ratatui</code> TUIs — the UI. We created a very simple UI with just one widget in
the previous tutorial, but here we’ll explore some more sophisticated layouts.</p>
<div id="admonition-attention" class="admonition warning">
<div class="admonition-title">
<p>Attention</p>
<p><a class="admonition-anchor-link" href="tutorial/json-editor/ui.html#admonition-attention"></a></p>
</div>
<div>
<p>If you have created a UI before, you should know that the UI code can take up much more space than
you think it should, and this is not exception. We will only briefly cover all the functionality
available in <code>ratatui</code> and how the core of <code>ratatui</code> design works.</p>
<p>There will be links to more resources where they are covered in depth in the following sections.</p>
</div>
</div>
<h2 id="layout-basics"><a class="header" href="#layout-basics">Layout basics</a></h2>
<p>Our first step is to grasp how we render widgets onto the terminal.</p>
<p>In essence: Widgets are constructed and then drawn onto the screen using a <code>Frame</code>, which is placed
within a specified <code>Rect</code>.</p>
<p>Now, envision a scenario where we wish to divide our renderable <code>Rect</code> area into three distinct
areas. For this, we can use the <code>Layout</code> functionality in <code>ratatui</code>.</p>
<pre><code class="language-rust no_run noplayground">    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Length(3),
                Constraint::Min(1),
                Constraint::Length(3),
            ]
            .as_ref(),
        )
        .split(f.size());</code></pre>
<p>This can be likened to partitioning a large rectangle into smaller sections.</p>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="tutorial/json-editor/ui.html#admonition-tip"></a></p>
</div>
<div>
<p>For a comprehensive understanding of layout and constraints, refer to
<a href="tutorial/json-editor/./../how-to/layout-constraints-basics.html">Layout Constraints Basics</a>
and <a href="tutorial/json-editor/./../how-to/layout-constraints-intermediate.html">Layout Constraints Intermediate</a> sections.</p>
</div>
</div>
<p>In the example above, you can read the instructions aloud like this:</p>
<ol>
<li>Take the area <code>f.size()</code> (which is a rectangle), and cut it into three vertical pieces (making
horizontal cuts).</li>
<li>The first section will be 3 lines tall</li>
<li>The second section should never be smaller than one line tall, but can expand if needed.</li>
<li>The final section should also be 3 lines tall</li>
</ol>
<p>For those visual learners, I have the following graphic:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="584" height="256">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="584" height="256"></rect>
  <text x="90" y="28" >Top</text>
  <text x="122" y="28" >segment</text>
  <text x="186" y="28" >always</text>
  <text x="90" y="44" >remains</text>
  <text x="154" y="44" >3</text>
  <text x="170" y="44" >lines</text>
  <text x="90" y="204" >Bottom</text>
  <text x="146" y="204" >segment</text>
  <text x="210" y="204" >is</text>
  <text x="90" y="220" >consistently</text>
  <text x="194" y="220" >3</text>
  <text x="210" y="220" >lines</text>
  <text x="378" y="28" >Constraint::Length</text>
  <line x1="536" y1="22" x2="552" y2="22" class="solid"></line>
  <line x1="536" y1="26" x2="552" y2="26" class="solid"></line>
  <text x="562" y="28" >3</text>
  <text x="58" y="108" >Middle</text>
  <text x="114" y="108" >segment</text>
  <text x="178" y="108" >maintains</text>
  <text x="258" y="108" >a</text>
  <text x="274" y="108" >minimum</text>
  <text x="58" y="124" >height</text>
  <text x="114" y="124" >of</text>
  <text x="138" y="124" >1</text>
  <text x="154" y="124" >line,</text>
  <text x="202" y="124" >but</text>
  <text x="234" y="124" >can</text>
  <text x="266" y="124" >expand</text>
  <text x="322" y="124" >if</text>
  <text x="58" y="140" >additional</text>
  <text x="146" y="140" >space</text>
  <text x="194" y="140" >is</text>
  <text x="218" y="140" >present.</text>
  <text x="378" y="140" >Constraint::Length</text>
  <text x="538" y="140" >&gt;</text>
  <line x1="552" y1="134" x2="560" y2="134" class="solid"></line>
  <line x1="552" y1="138" x2="560" y2="138" class="solid"></line>
  <text x="570" y="140" >1</text>
  <text x="378" y="204" >Constraint::Length</text>
  <line x1="536" y1="198" x2="552" y2="198" class="solid"></line>
  <line x1="536" y1="202" x2="552" y2="202" class="solid"></line>
  <text x="562" y="204" >3</text>
  <g>
    <line x1="4" y1="8" x2="364" y2="8" class="solid"></line>
    <line x1="4" y1="8" x2="4" y2="232" class="solid"></line>
    <line x1="364" y1="8" x2="364" y2="232" class="solid"></line>
    <line x1="4" y1="56" x2="364" y2="56" class="solid"></line>
    <line x1="4" y1="184" x2="364" y2="184" class="solid"></line>
    <line x1="4" y1="232" x2="364" y2="232" class="solid"></line>
  </g>
</svg></pre>
<p>Now that we have that out of the way, let us create the TUI for our application.</p>
<h2 id="the-function-signature"><a class="header" href="#the-function-signature">The function signature</a></h2>
<p>Our ui function needs two things to successfully create our UI elements. The <code>Frame</code> which contains
the size of the terminal at render time (this is important, because it allows us to take resizeable
terminals into account), and the application state.</p>
<pre><code class="language-rust no_run noplayground">pub fn ui&lt;B: Backend&gt;(f: &amp;mut Frame&lt;B&gt;, app: &amp;App) {</code></pre>
<p>Before we proceed, let’s implement a <code>centered_rect</code> helper function. This code is adapted from the
<a href="https://github.com/ratatui-org/ratatui/blob/main/examples/popup.rs">popup example</a> found in the
official repo.</p>
<pre><code class="language-rust no_run noplayground">/// helper function to create a centered rect using up certain percentage of the available rect `r`
fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -&gt; Rect {
    // Cut the given rectangle into three vertical pieces
    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Percentage((100 - percent_y) / 2),
                Constraint::Percentage(percent_y),
                Constraint::Percentage((100 - percent_y) / 2),
            ]
            .as_ref(),
        )
        .split(r);

    // Then cut the middle vertical piece into three width-wise pieces
    Layout::default()
        .direction(Direction::Horizontal)
        .constraints(
            [
                Constraint::Percentage((100 - percent_x) / 2),
                Constraint::Percentage(percent_x),
                Constraint::Percentage((100 - percent_x) / 2),
            ]
            .as_ref(),
        )
        .split(popup_layout[1])[1] // Return the middle chunk
}</code></pre>
<p>This will be useful for the later subsections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-main-screen"><a class="header" href="#the-main-screen">The Main screen</a></h1>
<p>Because we want the <code>Main</code> screen to be rendered behind the editing popup, we will draw it first,
and then have additional logic about our popups</p>
<h2 id="our-layout"><a class="header" href="#our-layout">Our layout</a></h2>
<p>Now that we have our <code>Frame</code>, we can actually begin drawing widgets onto it. We will begin by
creating out layout.</p>
<pre><code class="language-rust no_run noplayground">    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Length(3),
                Constraint::Min(1),
                Constraint::Length(3),
            ]
            .as_ref(),
        )
        .split(f.size());</code></pre>
<p>The variable <code>chunks</code> now contains a length 3 array of <code>Rect</code> objects that contain the top left
corner of their space, and their size. We will use these later, after we prepare our widgets.</p>
<h2 id="the-title"><a class="header" href="#the-title">The title</a></h2>
<p>The title is an important piece for any application. It helps the user understand what they can do
and where they are. To create our title, we are going to use a <code>Paragraph</code> widget (which is used to
display only text), and we are going to tell that <code>Paragraph</code> we want a border all around it by
giving it a <code>Block</code> with borders enabled. (See <a href="tutorial/json-editor/./../how-to/block.html">How-To: Block</a> and
<a href="tutorial/json-editor/./../how-to/paragraph.html">How-To: Paragraph</a> for more information about <code>Block</code> and <code>Paragraph</code>).</p>
<pre><code class="language-rust no_run noplayground">    let title_block = Block::default()
        .borders(Borders::ALL)
        .style(Style::default());

    let title = Paragraph::new(Text::styled(
        &quot;Create New Json&quot;,
        Style::default().fg(Color::Green),
    ))
    .block(title_block);

    f.render_widget(title, chunks[0]);</code></pre>
<p>In this code, the first thing we do, is create a <code>Block</code> with all borders enabled, and the default
style. Next, we created a paragraph widget with the text “Create New Json” styled green. (See
<a href="tutorial/json-editor/./../how-to/paragraph.html">How-To: Paragraphs</a> for more information about creating paragraphs and
<a href="tutorial/json-editor/./../how-to/styling-text.html">How-To: Styling-Text</a> for styling text) Finally, we call
<code>render_widget</code> on our <code>Frame</code>, and give it the widget we want to render it, and the <code>Rect</code>
representing where it needs to go and what size it should be. (this is the way all widgets are
drawn)</p>
<h2 id="the-list-of-existing-pairs"><a class="header" href="#the-list-of-existing-pairs">The list of existing pairs.</a></h2>
<p>We would also like the user to be able to see any key-value pairs that they have already entered.
For this, we will be using another widget, the <code>List</code>. The list is what it sounds like - it creates
a new line of text for each <code>ListItem</code>, and it supports passing in a state so you can implement
selecting items on the list with little extra work. We will not be implementing selection, as we
simply want the user to be able to see what they have already entered.</p>
<pre><code class="language-rust no_run noplayground">    let mut list_items = Vec::&lt;ListItem&gt;::new();

    for key in app.pairs.keys() {
        list_items.push(ListItem::new(Line::from(Span::styled(
            format!(&quot;{: &lt;25} : {}&quot;, key, app.pairs.get(key).unwrap()),
            Style::default().fg(Color::Yellow),
        ))));
    }

    let list = List::new(list_items);

    f.render_widget(list, chunks[1]);</code></pre>
<p>For more information on Line, Span, and Style see
<a href="tutorial/json-editor/./../how-to/displaying-text.html">How-To: Displaying Text</a></p>
<p>In this piece of the function, we create a vector of <code>ListItem</code>s, and populate it with styled and
formatted key-value pairs. Finally, we create the <code>List</code> widget, and render it.</p>
<h2 id="the-bottom-navigational-bar"><a class="header" href="#the-bottom-navigational-bar">The bottom navigational bar</a></h2>
<p>It can help new users of your application, to see hints about what keys they can press. For this, we
are going to implement two bars, and another layout. These two bars will contain information on 1)
The current screen (<code>Main</code>, <code>Editing</code>, and <code>Exiting</code>), and 2) what keybinds are available.</p>
<p>Here, we will create a <code>Vec</code> of <code>Span</code> which will be converted later into a single line by the
<code>Paragraph</code>. (A <code>Span</code> is different from a <code>Line</code>, because a <code>Span</code> indicates a section of <code>Text</code>
with a style applied, and doesn’t end with a newline)</p>
<pre><code class="language-rust no_run noplayground">    let current_navigation_text = vec![
        // The first half of the text
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(&quot;Normal Mode&quot;, Style::default().fg(Color::Green)),
            CurrentScreen::Editing =&gt; {
                Span::styled(&quot;Editing Mode&quot;, Style::default().fg(Color::Yellow))
            }
            CurrentScreen::Exiting =&gt; Span::styled(&quot;Exiting&quot;, Style::default().fg(Color::LightRed)),
        }
        .to_owned(),
        // A white divider bar to separate the two sections
        Span::styled(&quot; | &quot;, Style::default().fg(Color::White)),
        // The final section of the text, with hints on what the user is editing
        {
            if let Some(editing) = &amp;app.currently_editing {
                match editing {
                    CurrentlyEditing::Key =&gt; {
                        Span::styled(&quot;Editing Json Key&quot;, Style::default().fg(Color::Green))
                    }
                    CurrentlyEditing::Value =&gt; {
                        Span::styled(&quot;Editing Json Value&quot;, Style::default().fg(Color::LightGreen))
                    }
                }
            } else {
                Span::styled(&quot;Not Editing Anything&quot;, Style::default().fg(Color::DarkGray))
            }
        },
    ];

    let mode_footer = Paragraph::new(Line::from(current_navigation_text))
        .block(Block::default().borders(Borders::ALL));</code></pre>
<p>Next, we are also going to make a hint in the navigation bar with available keys. This one does not
have several sections of text with different styles, and is thus less code.</p>
<pre><code class="language-rust no_run noplayground">    let current_keys_hint = {
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Editing =&gt; Span::styled(
                &quot;(ESC) to cancel/(Tab) to switch boxes/enter to complete&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Exiting =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
        }
    };

    let key_notes_footer =
        Paragraph::new(Line::from(current_keys_hint)).block(Block::default().borders(Borders::ALL));</code></pre>
<p>Finally, we are going to create our first nested layout. Because the <code>Layout.split</code> function
requires a <code>Rect</code>, and not a <code>Frame</code>, we can pass one of our chunks from the previous layout as the
space for the new layout. If you remember the bottom most section from the above graphic:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="496" height="96">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="496" height="96"></rect>
  <rect x="4" y="8" width="280" height="64" class="solid nofill" rx="0"></rect>
  <text x="66" y="28" >This</text>
  <text x="106" y="28" >section</text>
  <text x="170" y="28" >should</text>
  <text x="50" y="44" >always</text>
  <text x="106" y="44" >be</text>
  <text x="130" y="44" >3</text>
  <text x="146" y="44" >lines</text>
  <text x="194" y="44" >tall</text>
  <text x="298" y="12" >Constraint::Length</text>
  <line x1="456" y1="6" x2="472" y2="6" class="solid"></line>
  <line x1="456" y1="10" x2="472" y2="10" class="solid"></line>
  <text x="482" y="12" >3</text>
</svg></pre>
<p>We will create a new layout in this space by passing it (<code>chunks[2]</code>) as the parameter for <code>split</code>.</p>
<pre><code class="language-rust no_run noplayground">    let footer_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)].as_ref())
        .split(chunks[2]);</code></pre>
<p>This code is the visual equivalent of this:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="488" height="96">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="488" height="96"></rect>
  <rect x="4" y="8" width="272" height="64" class="solid nofill" rx="0"></rect>
  <line x1="140" y1="16" x2="140" y2="64" class="solid"></line>
  <text x="18" y="44" >Length</text>
  <line x1="72" y1="38" x2="88" y2="38" class="solid"></line>
  <line x1="72" y1="42" x2="88" y2="42" class="solid"></line>
  <text x="98" y="44" >50%</text>
  <text x="154" y="44" >Length</text>
  <line x1="208" y1="38" x2="224" y2="38" class="solid"></line>
  <line x1="208" y1="42" x2="224" y2="42" class="solid"></line>
  <text x="234" y="44" >50%</text>
  <text x="290" y="12" >Constraint::Length</text>
  <line x1="448" y1="6" x2="464" y2="6" class="solid"></line>
  <line x1="448" y1="10" x2="464" y2="10" class="solid"></line>
  <text x="474" y="12" >3</text>
</svg></pre>
<p>And now we can render our footer paragraphs in the appropriate spaces.</p>
<pre><code class="language-rust no_run noplayground">    f.render_widget(mode_footer, footer_chunks[0]);
    f.render_widget(key_notes_footer, footer_chunks[1]);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-editing-popup"><a class="header" href="#the-editing-popup">The Editing Popup</a></h1>
<p>Now that the <code>Main</code> screen is rendered, we now need to check if the <code>Editing</code> popup needs to be
rendered. Since the <code>ratatui</code> renderer simply writes over the cells within a <code>Rect</code> on a
<code>render_widget</code>, we simply need to give <code>render_widget</code> an area on top of our <code>Main</code> screen to
create the appearance of a popup.</p>
<h2 id="popup-area-and-title"><a class="header" href="#popup-area-and-title">Popup area and title</a></h2>
<p>The first thing we will do, is draw the <code>Block</code> that will contain the popup. We will give this
<code>Block</code> a title to display as well to explain to the user what it is. (We will cover <code>centered_rect</code>
below)</p>
<pre><code class="language-rust no_run noplayground">    if let Some(editing) = &amp;app.currently_editing {
        let popup_block = Block::default()
            .title(&quot;Enter a new key-value pair&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let area = centered_rect(60, 25, f.size());
        f.render_widget(popup_block, area);</code></pre>
<h2 id="popup-contents"><a class="header" href="#popup-contents">Popup contents</a></h2>
<p>Now that we have where our popup is going to go, we can create the layout for the popup, and create
and draw the widgets inside of it.</p>
<p>First, we will create split the <code>Rect</code> given to us by <code>centered_rect</code>, and create a layout from it.
Note the use of <code>margin(1)</code>, which gives a 1 space margin around any layout block, meaning our new
blocks and widgets don’t overwrite anything from the first popup block.</p>
<pre><code class="language-rust no_run noplayground">        let popup_chunks = Layout::default()
            .direction(Direction::Horizontal)
            .margin(1)
            .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
            .split(area);</code></pre>
<p>Now that we have the layout for where we want to display the keys and values, we will actually
create the blocks and paragraphs to show what the user has already entered.</p>
<pre><code class="language-rust no_run noplayground">        let mut key_block = Block::default().title(&quot;Key&quot;).borders(Borders::ALL);
        let mut value_block = Block::default().title(&quot;Value&quot;).borders(Borders::ALL);

        let active_style = Style::default().bg(Color::LightYellow).fg(Color::Black);

        match editing {
            CurrentlyEditing::Key =&gt; key_block = key_block.style(active_style),
            CurrentlyEditing::Value =&gt; value_block = value_block.style(active_style),
        };

        let key_text = Paragraph::new(app.key_input.clone()).block(key_block);
        f.render_widget(key_text, popup_chunks[0]);

        let value_text = Paragraph::new(app.value_input.clone()).block(value_block);
        f.render_widget(value_text, popup_chunks[1]);</code></pre>
<p>Note that we are declaring the blocks as variables, and then adding extra styling to the block the
user is currently editing. Then we create the <code>Paragraph</code> widgets, and assign the blocks with those
variables. Also note how we used the <code>popup_chunks</code> layout instead of the <code>popup_block</code> layout to
render these widgets into.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-exit-popup"><a class="header" href="#the-exit-popup">The Exit Popup</a></h1>
<p>We have a way for the user to view their already entered key-value pairs, and we have a way for the
user to enter new ones. The last screen we need to create, is the exit/confirmation screen.</p>
<p>In this screen, we are asking the user if they want to output the key-value pairs they have entered
in the <code>stdout</code> pipe, or close without outputting anything.</p>
<pre><code class="language-rust no_run noplayground">    if let CurrentScreen::Exiting = app.current_screen {
        f.render_widget(Clear, f.size()); //this clears the entire screen and anything already drawn
        let popup_block = Block::default()
            .title(&quot;Y/N&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let exit_text = Text::styled(
            &quot;Would you like to output the buffer as json? (y/n)&quot;,
            Style::default().fg(Color::Red),
        );
        // the `trim: false` will stop the text from being cut off when over the edge of the block
        let exit_paragraph = Paragraph::new(exit_text)
            .block(popup_block)
            .wrap(Wrap { trim: false });

        let area = centered_rect(60, 25, f.size());
        f.render_widget(exit_paragraph, area);
    }</code></pre>
<p>The only thing in this part that we haven’t done before, is use the <code>Clear</code> widget. This is a
special widget that does what the name suggests - it clears everything in the space it is rendered.
In this case, it clears all of the menu that was prerendered behind it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closing-thoughts"><a class="header" href="#closing-thoughts">Closing Thoughts</a></h1>
<p>This tutorial should get you started with a basic understanding of the flow of a <code>ratatui</code> program.
However, this is only <em>one</em> way to create a <code>ratatui</code> application. Because <code>ratatui</code> is relatively
low level compared to other UI frameworks, almost any application model can be implemented. You can
explore more of these in <a href="tutorial/json-editor/./../../concepts/application-patterns.html">Concepts: Application Patterns</a>
and get some inspiration for what model will work best for your application.</p>
<h2 id="finished-files"><a class="header" href="#finished-files">Finished Files</a></h2>
<p>Here you can find the finished project used for the tutorial. You can test this application by
yourself, but running</p>
<pre><code>cargo run &gt; test.json
</code></pre>
<p>and double checking the output.</p>
<h4 id="mainrs-2"><a class="header" href="#mainrs-2">Main.rs</a></h4>
<pre><code class="language-rust no_run noplayground">use std::{error::Error, io};

use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::{Backend, CrosstermBackend},
    Terminal,
};

mod app;
mod ui;
use crate::{
    app::{App, CurrentScreen, CurrentlyEditing},
    ui::ui,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // setup terminal
    enable_raw_mode()?;
    let mut stderr = io::stderr(); // This is a special case. Normally using stdout is fine
    execute!(stderr, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stderr);
    let mut terminal = Terminal::new(backend)?;

    // create app and run it
    let mut app = App::new();
    let res = run_app(&amp;mut terminal, &amp;mut app);


    // restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Ok(do_print) = res {
        if do_print {
            app.print_json()?;
        }
    } else if let Err(err) = res {
        println!(&quot;{err:?}&quot;);
    }

    Ok(())
}

fn run_app&lt;B: Backend&gt;(terminal: &amp;mut Terminal&lt;B&gt;, app: &amp;mut App) -&gt; io::Result&lt;bool&gt; {
    loop {
        terminal.draw(|f| ui(f, app))?;

        if let Event::Key(key) = event::read()? {
            match app.current_screen {
                CurrentScreen::Main =&gt; match key.code {
                    KeyCode::Char('e') =&gt; {
                        app.current_screen = CurrentScreen::Editing;
                        app.currently_editing = Some(CurrentlyEditing::Key);
                    }
                    KeyCode::Char('q') =&gt; {
                        app.current_screen = CurrentScreen::Exiting;
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Exiting =&gt; match key.code {
                    KeyCode::Char('y') =&gt; {
                        return Ok(true);
                    }
                    KeyCode::Char('n') | KeyCode::Char('q') =&gt; {
                        return Ok(false);
                    }
                    _ =&gt; {}
                },
                CurrentScreen::Editing if key.kind == KeyEventKind::Press =&gt; {
                    match key.code {
                        KeyCode::Enter =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.currently_editing = Some(CurrentlyEditing::Value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.save_key_value();
                                        app.current_screen = CurrentScreen::Main;
                                    }
                                }
                            }
                        }
                        KeyCode::Backspace =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.pop();
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.pop();
                                    }
                                }
                            }
                        }
                        KeyCode::Esc =&gt; {
                            app.current_screen = CurrentScreen::Main;
                            app.currently_editing = None;
                        }
                        KeyCode::Tab =&gt; {
                            app.toggle_editing();
                        }
                        KeyCode::Char(value) =&gt; {
                            if let Some(editing) = &amp;app.currently_editing {
                                match editing {
                                    CurrentlyEditing::Key =&gt; {
                                        app.key_input.push(value);
                                    }
                                    CurrentlyEditing::Value =&gt; {
                                        app.value_input.push(value);
                                    }
                                }
                            }
                        }
                        _ =&gt; {}
                    }
                }
                _ =&gt; {}
            }
        }
    }
}
</code></pre>
<h4 id="apprs-2"><a class="header" href="#apprs-2">App.rs</a></h4>
<pre><code class="language-rust no_run noplayground">use serde_json::Result;

pub enum CurrentScreen {
    Main,
    Editing,
    Exiting,
}

pub enum CurrentlyEditing {
    Key,
    Value,
}

pub struct App {
    pub key_input: String,              // the currently being edited json key.
    pub value_input: String,            // the currently being edited json value.
    pub pairs: HashMap&lt;String, String&gt;, // The representation of our key and value pairs with serde Serialize support
    pub current_screen: CurrentScreen, // the current screen the user is looking at, and will later determine what is rendered.
    pub currently_editing: Option&lt;CurrentlyEditing&gt;, // the optional state containing which of the key or value pair the user is editing. It is an option, because when the user is not directly editing a key-value pair, this will be set to `None`.
}

impl App {
    pub fn new() -&gt; App {
        App {
            key_input: String::new(),
            value_input: String::new(),
            pairs: HashMap::new(),
            current_screen: CurrentScreen::Main,
            currently_editing: None,
        }
    }

    pub fn save_key_value(&amp;mut self) {
        self.pairs
            .insert(self.key_input.clone(), self.value_input.clone());

        self.key_input = String::new();
        self.value_input = String::new();
        self.currently_editing = None;
    }

    pub fn toggle_editing(&amp;mut self) {
        if let Some(edit_mode) = &amp;self.currently_editing {
            match edit_mode {
                CurrentlyEditing::Key =&gt; self.currently_editing = Some(CurrentlyEditing::Value),
                CurrentlyEditing::Value =&gt; self.currently_editing = Some(CurrentlyEditing::Key),
            };
        } else {
            self.currently_editing = Some(CurrentlyEditing::Key);
        }
    }

    pub fn print_json(&amp;self) -&gt; Result&lt;()&gt; {
        let output = serde_json::to_string(&amp;self.pairs)?;
        println!(&quot;{}&quot;, output);
        Ok(())
    }
}</code></pre>
<h4 id="uirs-2"><a class="header" href="#uirs-2">UI.rs</a></h4>
<pre><code class="language-rust no_run noplayground">use ratatui::{
    backend::Backend,
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Style},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Clear, List, ListItem, Paragraph, Wrap},
    Frame,
};

use crate::app::{App, CurrentScreen, CurrentlyEditing};

pub fn ui&lt;B: Backend&gt;(f: &amp;mut Frame&lt;B&gt;, app: &amp;App) {
    // Create the layout sections.
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Length(3),
                Constraint::Min(1),
                Constraint::Length(3),
            ]
            .as_ref(),
        )
        .split(f.size());

    let title_block = Block::default()
        .borders(Borders::ALL)
        .style(Style::default());

    let title = Paragraph::new(Text::styled(
        &quot;Create New Json&quot;,
        Style::default().fg(Color::Green),
    ))
    .block(title_block);

    f.render_widget(title, chunks[0]);
    let mut list_items = Vec::&lt;ListItem&gt;::new();

    for key in app.pairs.keys() {
        list_items.push(ListItem::new(Line::from(Span::styled(
            format!(&quot;{: &lt;25} : {}&quot;, key, app.pairs.get(key).unwrap()),
            Style::default().fg(Color::Yellow),
        ))));
    }

    let list = List::new(list_items);

    f.render_widget(list, chunks[1]);
    let current_navigation_text = vec![
        // The first half of the text
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(&quot;Normal Mode&quot;, Style::default().fg(Color::Green)),
            CurrentScreen::Editing =&gt; {
                Span::styled(&quot;Editing Mode&quot;, Style::default().fg(Color::Yellow))
            }
            CurrentScreen::Exiting =&gt; Span::styled(&quot;Exiting&quot;, Style::default().fg(Color::LightRed)),
        }
        .to_owned(),
        // A white divider bar to separate the two sections
        Span::styled(&quot; | &quot;, Style::default().fg(Color::White)),
        // The final section of the text, with hints on what the user is editing
        {
            if let Some(editing) = &amp;app.currently_editing {
                match editing {
                    CurrentlyEditing::Key =&gt; {
                        Span::styled(&quot;Editing Json Key&quot;, Style::default().fg(Color::Green))
                    }
                    CurrentlyEditing::Value =&gt; {
                        Span::styled(&quot;Editing Json Value&quot;, Style::default().fg(Color::LightGreen))
                    }
                }
            } else {
                Span::styled(&quot;Not Editing Anything&quot;, Style::default().fg(Color::DarkGray))
            }
        },
    ];

    let mode_footer = Paragraph::new(Line::from(current_navigation_text))
        .block(Block::default().borders(Borders::ALL));

    let current_keys_hint = {
        match app.current_screen {
            CurrentScreen::Main =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Editing =&gt; Span::styled(
                &quot;(ESC) to cancel/(Tab) to switch boxes/enter to complete&quot;,
                Style::default().fg(Color::Red),
            ),
            CurrentScreen::Exiting =&gt; Span::styled(
                &quot;(q) to quit / (e) to make new pair&quot;,
                Style::default().fg(Color::Red),
            ),
        }
    };

    let key_notes_footer =
        Paragraph::new(Line::from(current_keys_hint)).block(Block::default().borders(Borders::ALL));

    let footer_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)].as_ref())
        .split(chunks[2]);

    f.render_widget(mode_footer, footer_chunks[0]);
    f.render_widget(key_notes_footer, footer_chunks[1]);

    if let Some(editing) = &amp;app.currently_editing {
        let popup_block = Block::default()
            .title(&quot;Enter a new key-value pair&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let area = centered_rect(60, 25, f.size());
        f.render_widget(popup_block, area);

        let popup_chunks = Layout::default()
            .direction(Direction::Horizontal)
            .margin(1)
            .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
            .split(area);

        let mut key_block = Block::default().title(&quot;Key&quot;).borders(Borders::ALL);
        let mut value_block = Block::default().title(&quot;Value&quot;).borders(Borders::ALL);

        let active_style = Style::default().bg(Color::LightYellow).fg(Color::Black);

        match editing {
            CurrentlyEditing::Key =&gt; key_block = key_block.style(active_style),
            CurrentlyEditing::Value =&gt; value_block = value_block.style(active_style),
        };

        let key_text = Paragraph::new(app.key_input.clone()).block(key_block);
        f.render_widget(key_text, popup_chunks[0]);

        let value_text = Paragraph::new(app.value_input.clone()).block(value_block);
        f.render_widget(value_text, popup_chunks[1]);
    }

    if let CurrentScreen::Exiting = app.current_screen {
        f.render_widget(Clear, f.size()); //this clears the entire screen and anything already drawn
        let popup_block = Block::default()
            .title(&quot;Y/N&quot;)
            .borders(Borders::NONE)
            .style(Style::default().bg(Color::DarkGray));

        let exit_text = Text::styled(
            &quot;Would you like to output the buffer as json? (y/n)&quot;,
            Style::default().fg(Color::Red),
        );
        // the `trim: false` will stop the text from being cut off when over the edge of the block
        let exit_paragraph = Paragraph::new(exit_text)
            .block(popup_block)
            .wrap(Wrap { trim: false });

        let area = centered_rect(60, 25, f.size());
        f.render_widget(exit_paragraph, area);
    }
}

/// helper function to create a centered rect using up certain percentage of the available rect `r`
fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -&gt; Rect {
    // Cut the given rectangle into three vertical pieces
    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints(
            [
                Constraint::Percentage((100 - percent_y) / 2),
                Constraint::Percentage(percent_y),
                Constraint::Percentage((100 - percent_y) / 2),
            ]
            .as_ref(),
        )
        .split(r);

    // Then cut the middle vertical piece into three width-wise pieces
    Layout::default()
        .direction(Direction::Horizontal)
        .constraints(
            [
                Constraint::Percentage((100 - percent_x) / 2),
                Constraint::Percentage(percent_x),
                Constraint::Percentage((100 - percent_x) / 2),
            ]
            .as_ref(),
        )
        .split(popup_layout[1])[1] // Return the middle chunk
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>In this section, we will cover various concepts associated with terminal user interfaces, such as:</p>
<ul>
<li>Application patterns</li>
<li>Event handling</li>
<li>Storing state</li>
<li>Rendering</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<p>The world of UI development consists mainly of two dominant paradigms: retained mode and immediate
mode. Most traditional GUI libraries operate under the retained mode paradigm. However, <code>ratatui</code>
employs the immediate mode rendering approach. for TUI development.</p>
<p>This makes <code>ratatui</code> is different from GUI frameworks you might use, because it only updates when
you tell it to.</p>
<h2 id="what-is-immediate-mode-rendering"><a class="header" href="#what-is-immediate-mode-rendering">What is Immediate Mode Rendering?</a></h2>
<p>Immediate mode rendering is a UI paradigm where the UI is recreated every frame. Instead of creating
a fixed set of UI widgets and updating their state, you “draw” your UI from scratch in every frame
based on the current application state.</p>
<p>In a nutshell:</p>
<ul>
<li>Retained Mode: You set up your UI once, create widgets, and later modify their properties or
handle their events.</li>
<li>Immediate Mode: You redraw your UI every frame based on your application state. There’s no
permanent widget object in memory.</li>
</ul>
<p>In <code>ratatui</code>, every frame draws the UI anew.</p>
<pre><code class="language-rust">loop {
    terminal.draw(|f| {
        if state.condition {
            f.render_widget(SomeWidget::new(), layout);
        } else {
            f.render_widget(AnotherWidget::new(), layout);
        }
    })?;
}</code></pre>
<p><a href="https://caseymuratori.com/blog_0001">This article</a> and the accompanying YouTube video is worth your
time if you are new to the immediate mode rendering paradigm.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Z1qyvQsjK5Y?si=eiBHXiXIo3Z0u2zs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<p>This 4 minute talk about <code>IMGUI</code> is also tangentially relevant.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/LSRJ1jZq90k?si=8NB5yiZ8IGS_QE_E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<h2 id="advantages-of-immediate-mode-rendering"><a class="header" href="#advantages-of-immediate-mode-rendering">Advantages of Immediate Mode Rendering</a></h2>
<ul>
<li><strong>Simplicity</strong>: Without a persistent widget state, your UI logic becomes a direct reflection of
your application state. You don’t have to sync them or worry about past widget states.</li>
<li><strong>Flexibility</strong>: You can change your UI layout or logic any time, as nothing is set in stone. Want
to hide a widget conditionally? Just don’t draw it based on some condition.</li>
</ul>
<h2 id="disadvantages-of-immediate-mode-rendering"><a class="header" href="#disadvantages-of-immediate-mode-rendering">Disadvantages of Immediate Mode Rendering</a></h2>
<ul>
<li><strong>Render loop management</strong>: In Immediate mode rendering, the onus of rendering lies solely on the
programmer. Every visual update necessitates a call to <code>Backend.draw()</code>. Hence, if the rendering
thread is inadvertently blocked, the UI will not update until the thread resumes.</li>
</ul>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="concepts/rendering.html#admonition-note"></a></p>
</div>
<div>
<p>The <code>ratatui</code> library in particular only handles how widget would be rendered to a “Backend”, e.g.
<code>crossterm</code>. The <code>Backend</code> in question would use an external crate e.g. <code>crossterm</code> for actually drawing to the terminal.</p>
</div>
</div>
<ul>
<li>
<p><strong>Event loop orchestration</strong>: Along with managing “the render loop”, developers are also
responsible for handling “the event loop”. This involves deciding on a third-party library for the
job. <code>crossterm</code> is a popular crate to handle key inputs and you’ll find plenty of examples in the
repository and online for how to use it. <code>crossterm</code> also supports a <code>async</code> event stream, if you
are interested in using <code>tokio</code>.</p>
</li>
<li>
<p><strong>Architecture design considerations</strong>: With <code>ratatui</code>, out of the box, there’s little to no help
in organizing large applications. Ultimately, the decision on structure and discipline rests with
the developer to be principled.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling-1"><a class="header" href="#event-handling-1">Event Handling</a></h1>
<p>There are many ways to handle events with the <code>ratatui</code> library. Mostly becuase <code>ratatui</code> does not
directly expose any event catching; the programmer will depend on the chosen backend’s library.</p>
<p>However, there are a few ways to think about event handling that may help you. While this is not an
exhaustive list, it covers a few of the more common implementations. But remember, the correct way,
is the one that works for you and your current application.</p>
<h3 id="centralized-event-handling"><a class="header" href="#centralized-event-handling">Centralized event handling</a></h3>
<p>This is the simplest way to handle events because it handles all of the events as they appear. It is
often simply a match on the results of <code>event::read()?</code> (in crossterm) on the different supported
keys. Pros: This has the advantage of requiring no message passing, and allows the programmer to
edit all of the possible keyboard events in one place.</p>
<p>Cons: However, this particular way of handling events simply does not scale well. Because <em>all</em>
events are handled in one place, you will be unable to split different groups of keybinds out into
separate locations.</p>
<h3 id="centralized-catching-message-passing"><a class="header" href="#centralized-catching-message-passing">Centralized catching, message passing</a></h3>
<p>This way of handling events involves polling for events in one place, and then sending
messages/calling sub functions with the event that was caught. Pros: This has a similar appeal to
the first method in its simplicity. With this paradigm, you can easily split extensive pattern
matching into sub functions that can go in separate files. This way is also the idea often used in
basic multi-threaded applications because message channels are used to pass multi-threaded safe
messages.</p>
<p>Cons: This method requires a main loop to be running to consistently poll for events in a
centralized place.</p>
<h3 id="distributed-event-loopssegmented-applications"><a class="header" href="#distributed-event-loopssegmented-applications">Distributed event loops/segmented applications</a></h3>
<p>In this style, control of the <code>Terminal</code> and the main loop to a sub-module. In this case, the entire
rendering and event handling responsibilities can be safely passed to the sub-module. In theory, an
application built like this doesn’t need a centralized event listener. Pros: There is no centralized
event loop that you need to update whenever a new sub-module is created.</p>
<p>Cons: However, if several sub-modules in your application have similar event handling loops, this
way could lead to a lot of duplicated code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-elm-architecture-tea-with-ratatui"><a class="header" href="#using-the-elm-architecture-tea-with-ratatui">Using The Elm Architecture (TEA) with <code>ratatui</code></a></h1>
<p>When building terminal user interfaces (TUI) with <code>ratatui</code>, it’s helpful to have a solid structure
for organizing your application. One proven architecture comes from the Elm language, known simply
as The Elm Architecture (TEA).</p>
<p>In this post, we’ll explore how to apply The Elm Architecture to <code>ratatui</code> TUI apps.</p>
<h2 id="the-elm-architecture-a-quick-overview"><a class="header" href="#the-elm-architecture-a-quick-overview">The Elm Architecture: A Quick Overview</a></h2>
<p>At its core, the Elm Architecture is split into three main components:</p>
<ul>
<li><strong>Model</strong>: This is your application’s state. It contains all the data your application works with.</li>
<li><strong>Update</strong>: When there’s a change (like user input), the update function takes the current model
and the input, and produces a new model.</li>
<li><strong>View</strong>: This function is responsible for displaying your model to the user. In Elm, it produces
HTML. In our case, it’ll produce terminal UI elements.</li>
</ul>
<pre class="mermaid">sequenceDiagram
participant User
participant TUI Application

User-&gt;&gt;TUI Application: Input/Event/Message
TUI Application-&gt;&gt;TUI Application: Update (based on Model and Message)
TUI Application-&gt;&gt;TUI Application: Render View (from Model)
TUI Application--&gt;&gt;User: Display UI
</pre>
<h2 id="applying-tea-to-ratatui"><a class="header" href="#applying-tea-to-ratatui">Applying TEA to <code>ratatui</code></a></h2>
<ol>
<li>Define Your Model</li>
</ol>
<p>In <code>ratatui</code>, you’ll typically use a <code>struct</code> to represent your model:</p>
<pre><code class="language-rust">struct Model {
    //... your application's data goes here
}</code></pre>
<ol start="2">
<li>Handling Updates</li>
</ol>
<p>Updates in TEA are actions triggered by events, such as user inputs. The core idea is to map each of
these actions or events to a message. This can be achieved by creating an enum to keep track of
messages. Based on the received message, the current state of the model is used to determine the
next state.</p>
<p><strong>Defining a <code>Message</code> enum</strong></p>
<pre><code class="language-rust">enum Message {
    //... various inputs or actions that your app cares about
    // e.g., ButtonPressed, TextEntered, etc.
}</code></pre>
<p><strong><code>update()</code> function</strong></p>
<p>The update function is at the heart of this process. It takes the current model and a message, and
decides how the model should change in response to that message.</p>
<p>A key feature of TEA is immutability. Hence, the update function should avoid direct mutation of the
model. Instead, it should produce a new instance of the model reflecting the desired changes.</p>
<pre><code class="language-rust">fn update(model: &amp;Model, msg: Message) -&gt; Model {
    match msg {
        // Match each possible message and decide how the model should change
        // Return a new model reflecting those changes
    }
}</code></pre>
<p>In TEA, it’s crucial to maintain a clear separation between the data (model) and the logic that
alters it (update). This immutability principle ensures predictability and makes the application
easier to reason about.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="concepts/the-elm-architecture.html#admonition-note"></a></p>
</div>
<div>
<p>Hence, while immutability is emphasized in TEA, Rust developers can choose the most
suitable approach based on performance and their application’s needs.</p>
<p>For example, it would be perfectly valid to do the following:</p>
<pre><code class="language-rust">fn update(model: &amp;mut Model, msg: Message) {
    match msg {
        // Match each possible message and decide how the model should change
        // Modify existing mode reflecting those changes
    };
}</code></pre>
</div>
</div>
<ol start="3">
<li>Rendering the View</li>
</ol>
<p>The view function in the Elm Architecture is tasked with taking the current model and producing a
visual representation for the user. In the case of ratatui, it translates the model into terminal UI
elements. It’s essential that the view function remains a pure function: for a given state of the
model, it should always produce the same UI representation.</p>
<pre><code class="language-rust">fn view(model: &amp;Model) {
    //... use `ratatui` functions to draw your UI based on the model's state
}</code></pre>
<p>Every time the model is updated, the view function should be capable of reflecting those changes
accurately in the terminal UI.</p>
<p>In TEA, you are expected to ensure that your view function is side-effect free. The <code>view()</code>
function shouldn’t modify global state or perform any other actions. Its sole job is to map the
model to a visual representation.</p>
<p>For a given state of the model, the view function should always produce the same visual output. This
predictability makes your TUI application easier to reason about and debug.</p>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="concepts/the-elm-architecture.html#admonition-note-1"></a></p>
</div>
<div>
<p>With immediate mode rendering you may run into an issue: the <code>view</code> function is only aware of the
area available to draw in at render time.</p>
<p>For example, there’s not really a good way to choose how many columns you want to draw based on
width of the drawable area.</p>
<pre><code class="language-rust">fn view(model: &amp;Model) -&gt; Table {
  Table::new(vec![&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;])
}

fn main() {
  loop {
    ...
    terminal
      .draw(|f| {
        f.render_widget(view(&amp;model), f.size());
      })?;
    ...
  }
}</code></pre>
<p>This limitation is a recognized constraint of immediate mode GUIs. Overcoming it often involves
trade-offs. One common solution is to store the drawable size and reference it in the subsequent
frame, although this can introduce a frame delay in layout adjustments, leading to potential
flickering during the initial rendering when changes in screen size occur.</p>
<p>For this reason, you may choose to violate the <code>view</code> immutability principle and write a function
with a signature like so:</p>
<pre><code class="language-rust">fn view(model: &amp;mut Model) {
    //... use `ratatui` functions to draw your UI based on the model's state
    // Store size of drawing area if you have to in the model for next frame
}</code></pre>
<p>An alternative is to use the <code>Resize</code> event from <code>crossterm</code> and to clear the UI and force
redraw everything during that event.</p>
</div>
</div>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h2>
<p>When you put it all together, your main application loop might look something like:</p>
<ul>
<li>Listen for user input.</li>
<li>Map input to a <code>Message</code></li>
<li>Pass that message to the update function.</li>
<li>Draw the UI with the view function.</li>
</ul>
<p>This cycle repeats, ensuring your TUI is always up-to-date with user interactions.</p>
<p>As an illustrative example, here’s the <a href="concepts/./../tutorial/counter-app/single-function.html">Counter App</a>
refactored using TEA.</p>
<p>The notable difference from before is that we have an <code>Model</code> struct that captures the app state,
and a <code>Message</code> enum that captures the various actions your app can take.</p>
<pre><code class="language-rust">use anyhow::Result;
use ratatui::{
  prelude::{CrosstermBackend, Terminal},
  widgets::Paragraph,
};

// MODEL
struct Model {
  counter: i32,
  should_quit: bool,
}

// MESSAGES
enum Message {
  Increment,
  Decrement,
  Quit,
  None,
}

// UPDATE
fn update(model: &amp;mut Model, msg: Message) {
  match msg {
    Message::Increment =&gt; model.counter += 1,
    Message::Decrement =&gt; model.counter -= 1,
    Message::Quit =&gt; model.should_quit = true, // You can handle cleanup and exit here
    Message::None =&gt; (),
  }
}

// VIEW
fn view(model: &amp;Model) -&gt; Paragraph {
  Paragraph::new(format!(&quot;Counter: {}&quot;, model.counter))
}

// Convert Event to Message
// We don't need to pass in a `model` to this function in this example
// but you might need it as your project evolves
fn handle_event(_: &amp;Model) -&gt; Result&lt;Message&gt; {
  let message = if crossterm::event::poll(std::time::Duration::from_millis(250))? {
    if let crossterm::event::Event::Key(key) = crossterm::event::read()? {
      match key.code {
        crossterm::event::KeyCode::Char('j') =&gt; Message::Increment,
        crossterm::event::KeyCode::Char('k') =&gt; Message::Decrement,
        crossterm::event::KeyCode::Char('q') =&gt; Message::Quit,
        _ =&gt; Message::None,
      }
    } else {
      Message::None
    }
  } else {
    Message::None
  };
  Ok(message)
}

pub fn initialize_panic_handler() {
  let original_hook = std::panic::take_hook();
  std::panic::set_hook(Box::new(move |panic_info| {
    crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen).unwrap();
    crossterm::terminal::disable_raw_mode().unwrap();
    original_hook(panic_info);
  }));
}

fn main() -&gt; Result&lt;()&gt; {
  initialize_panic_handler();

  // Startup
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;

  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
  let mut model = Model { counter: 0, should_quit: false };

  loop {
    terminal.draw(|f| {
      f.render_widget(view(&amp;model), f.size());
    })?;

    let msg = handle_event(&amp;model)?;

    update(&amp;mut model, msg);

    if model.should_quit {
      break;
    }
  }

  // Shutdown
  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?;
  Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>As ratatui grows and evolves, this list may change, so make sure to check the
<a href="how-to/./https://github.com/ratatui-org/ratatui">main repo</a> if you are unsure.</p>
<h2 id="backend-selection"><a class="header" href="#backend-selection">Backend Selection</a></h2>
<p>See <a href="how-to/./choose-a-backend.html">How to Choose a Backend</a> for more information. However, for most cases, the
default <code>crossterm</code> backend is enough.</p>
<pre><code class="language-console"># Defaults to crossterm
cargo add ratatui
# Unset the default crossterm feature and select one of the other backends
cargo add ratatui --no-default-features --features=terminon
cargo add ratatui --no-default-features --features=termwiz
</code></pre>
<h2 id="all-widgets"><a class="header" href="#all-widgets">All-Widgets</a></h2>
<p>This feature enables some extra widgets that are not in <code>default</code> to save on compile time. As of
v0.21, the only widget in this feature group is the <code>calendar</code> widget, which can be enabled with the
<code>widget-calendar</code> feature.</p>
<pre><code class="language-console">cargo add ratatui --features all-widgets
</code></pre>
<h2 id="widget-calendar"><a class="header" href="#widget-calendar">Widget-Calendar</a></h2>
<p>This feature enables the calendar widget, which requires the <code>time</code> crate.</p>
<pre><code class="language-console">cargo add ratatui --features widget-calendar
</code></pre>
<h2 id="serde"><a class="header" href="#serde">Serde</a></h2>
<pre><code class="language-console">cargo add ratatui --features serde
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-choose-a-backend"><a class="header" href="#how-to-choose-a-backend">How to Choose a Backend</a></h1>
<div id="admonition-tldr" class="admonition abstract">
<div class="admonition-title">
<p>Tldr</p>
<p><a class="admonition-anchor-link" href="how-to/choose-a-backend.html#admonition-tldr"></a></p>
</div>
<div>
<p>Choose <a href="https://crates.io/crates/crossterm">Crossterm</a> for most tasks.</p>
</div>
</div>
<p>Ratatui interfaces with the terminal emulator through its “backends”. These are powerful libraries
that grant <code>ratatui</code> the ability to capture keypresses, maneuver the cursor, style the text with
colors and other features. As of now, <code>ratatui</code> supports three backends:</p>
<ul>
<li><a href="https://github.com/crossterm-rs/crossterm">Crossterm</a></li>
<li><a href="https://github.com/redox-os/termion">Termion</a></li>
<li><a href="https://github.com/wez/wezterm/tree/main/termwiz">Termwiz</a></li>
</ul>
<p>Selecting a backend does influence your project’s structure, but the core functionalities remain
consistent across all options. Here’s a flowchart that can help you make your decision.</p>
<pre class="mermaid">graph TD;
    Q1[Is the TUI only for Wezterm users?]
    Q2[Is Windows compatibility important?]
    Q3[Are you familiar with Crossterm?]
    Q4[Are you familiar with Termion?]
    Crossterm
    Termwiz
    Termion

    Q1 --&gt;|Yes| Termwiz
    Q1 --&gt;|No| Q2
    Q2 --&gt;|Yes| Crossterm
    Q2 --&gt;|No| Q3
    Q3 --&gt;|Yes| Crossterm
    Q3 --&gt;|No| Q4
    Q4 --&gt;|Yes| Termion
    Q4 --&gt;|No| Crossterm
</pre>
<p>Though we try to make sure that all backends are fully-supported, the most commonly-used backend is
Crossterm. If you have no particular reason to use Termion or Termwiz, you will find it easiest to
learn Crossterm simply due to its popularity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-panic-hooks"><a class="header" href="#setup-panic-hooks">Setup Panic Hooks</a></h1>
<p>When building TUIs with <code>ratatui</code>, it’s vital to ensure that if your application encounters a panic,
it gracefully returns to the original terminal state. This prevents the terminal from getting stuck
in a modified state, which can be quite disruptive for users.</p>
<p>Here’s an example <code>initialize_panic_handler</code> that works with <code>crossterm</code> and with the Rust standard
library functionality and no external dependencies.</p>
<pre><code class="language-rust">pub fn initialize_panic_handler() {
  let original_hook = std::panic::take_hook();
  std::panic::set_hook(Box::new(move |panic_info| {
    crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen).unwrap();
    crossterm::terminal::disable_raw_mode().unwrap();
    original_hook(panic_info);
  }));
}

fn main() -&gt; Result&lt;()&gt; {
  initialize_panic_handler();

  // Startup
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(std::io::stderr(), crossterm::terminal::EnterAlternateScreen)?;

  let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;

  // ...

  // Shutdown
  crossterm::execute!(std::io::stderr(), crossterm::terminal::LeaveAlternateScreen)?;
  crossterm::terminal::disable_raw_mode()?;
  Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-hook-with-better-panic"><a class="header" href="#panic-hook-with-better-panic">Panic Hook with <code>better-panic</code></a></h1>
<p>Your application may panic for a number of reasons (e.g. when you call <code>.unwrap()</code> on a <code>None</code>). And
when this happens, you want to be a good citizen and:</p>
<ol>
<li>provide a useful stacktrace so that they can report errors back to you.</li>
<li>not leave the users terminal state in a botched condition, resetting it back to the way it was.</li>
</ol>
<p>Let’s assume you have a <code>tui.rs</code> file like so:</p>
<pre><code class="language-rust">use std::{io, panic};

use anyhow::Result;
use crossterm::{
  event::{DisableMouseCapture, EnableMouseCapture},
  terminal::{self, EnterAlternateScreen, LeaveAlternateScreen},
};

pub type Frame&lt;'a&gt; = tui::Frame&lt;'a, tui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;
pub type CrosstermTerminal = tui::Terminal&lt;tui::backend::CrosstermBackend&lt;std::io::Stderr&gt;&gt;;

use crate::{app::App, event::EventHandler, ui};
pub struct Tui {
  terminal: CrosstermTerminal,
  pub events: EventHandler,
}

impl Tui {
  pub fn new(terminal: CrosstermTerminal, events: EventHandler) -&gt; Self {
    Self { terminal, events }
  }

  pub fn init(&amp;mut self) -&gt; Result&lt;()&gt; {
    terminal::enable_raw_mode()?;
    crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;
    self.terminal.hide_cursor()?;
    self.terminal.clear()?;
    Ok(())
  }

  fn reset() -&gt; Result&lt;()&gt; {
    terminal::disable_raw_mode()?;
    crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;
    Ok(())
  }

  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
    Self::reset()?;
    self.terminal.show_cursor()?;
    Ok(())
  }
}</code></pre>
<p>Here’s an example of <code>initialize_panic_handler()</code> using
<a href="https://docs.rs/better-panic/latest/better_panic/"><code>better_panic</code></a> and
<a href="https://docs.rs/libc/latest/libc/"><code>libc</code></a> to provide a prettier backtrace by default.</p>
<pre><code class="language-rust">use better_panic::Settings;

use crate::tui::Tui;

pub fn initialize_panic_handler() {
  std::panic::set_hook(Box::new(|panic_info| {
    match Tui::new() {
      Ok(t) =&gt; {
        if let Err(r) = t.exit() {
          error!(&quot;Unable to exit Terminal: {r:?}&quot;);
        }
      },
      Err(r) =&gt; error!(&quot;Unable to exit Terminal: {r:?}&quot;),
    }
    Settings::auto().most_recent_first(false).lineno_suffix(true).create_panic_handler()(panic_info);
    std::process::exit(libc::EXIT_FAILURE);
  }));
}</code></pre>
<p>In the screenshot below, I added a <code>None.unwrap()</code> into a function that is called on a keypress, so
that you can see what a prettier stacktrace looks like:</p>
<p><img src="https://user-images.githubusercontent.com/1813121/252723080-18c15640-c75f-42b3-8aeb-d4e6ce323430.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-logging-with-tracing"><a class="header" href="#setup-logging-with-tracing">Setup Logging with tracing</a></h1>
<p>You can paste the following in any module in your project. Call <code>initialize_logging()?</code> in your
<code>main()</code> function.</p>
<pre><code class="language-rust">use std::path::PathBuf;

use anyhow::{anyhow, Context, Result};
use directories::ProjectDirs;
use tracing::error;
use tracing_subscriber::{
  self, filter::EnvFilter, prelude::__tracing_subscriber_SubscriberExt, util::SubscriberInitExt, Layer,
};

pub fn initialize_logging() -&gt; Result&lt;()&gt; {
  let directory = PathBuf::from(&quot;./log/&quot;);
  std::fs::create_dir_all(directory.clone()).context(format!(&quot;{directory:?} could not be created&quot;))?;
  let log_path = directory.join(&quot;ratatui-app.log&quot;);
  let log_file = std::fs::File::create(log_path)?;
  let file_subscriber = tracing_subscriber::fmt::layer()
    .with_file(true)
    .with_line_number(true)
    .with_writer(log_file)
    .with_target(false)
    .with_ansi(false)
    .with_filter(EnvFilter::from_default_env());
  tracing_subscriber::registry().with(file_subscriber).with(tui_logger::tracing_subscriber_layer()).init();
  let default_level = std::env::var(&quot;RUST_LOG&quot;).map_or(log::LevelFilter::Info, |val| {
    match val.to_lowercase().as_str() {
      &quot;off&quot; =&gt; log::LevelFilter::Off,
      &quot;error&quot; =&gt; log::LevelFilter::Error,
      &quot;warn&quot; =&gt; log::LevelFilter::Warn,
      &quot;info&quot; =&gt; log::LevelFilter::Info,
      &quot;debug&quot; =&gt; log::LevelFilter::Debug,
      &quot;trace&quot; =&gt; log::LevelFilter::Trace,
      _ =&gt; log::LevelFilter::Info,
    }
  });
  tui_logger::set_default_level(default_level);
  Ok(())
}

/// Similar to the `std::dbg!` macro, but generates `tracing` events rather
/// than printing to stdout.
///
/// By default, the verbosity level for the generated events is `DEBUG`, but
/// this can be customized.
#[macro_export]
macro_rules! trace_dbg {
    (target: $target:expr, level: $level:expr, $ex:expr) =&gt; {{
        match $ex {
            value =&gt; {
                tracing::event!(target: $target, $level, ?value, stringify!($ex));
                value
            }
        }
    }};
    (level: $level:expr, $ex:expr) =&gt; {
        trace_dbg!(target: module_path!(), level: $level, $ex)
    };
    (target: $target:expr, $ex:expr) =&gt; {
        trace_dbg!(target: $target, level: tracing::Level::DEBUG, $ex)
    };
    ($ex:expr) =&gt; {
        trace_dbg!(level: tracing::Level::DEBUG, $ex)
    };
}
</code></pre>
<p>The log level is decided by the <code>RUST_LOG</code> environment variable (default =
<code>log::LevelFilter::Info</code>).</p>
<p>Ideally, the location of the log files are decided by your environment variables. See
<a href="how-to/./handle-xdg-directories.html">the section on XDG directories</a> for how to handle that.</p>
<p>In addition to add a log file to the <code>data</code> folder, <code>initialize_logging()</code> also sets up <code>tui-logger</code>
with <code>tracing</code>, so that you can add a <code>tui-logger</code> widget to show the logs to your users on a key
press.</p>
<p><img src="https://user-images.githubusercontent.com/1813121/254093932-46d8c6fd-c572-4675-bcaf-45a36eed51ff.png" alt="Top half is a terminal with the TUI showing a Vertical split with tui-logger widget. Bottom half is a terminal showing the output of running tail -f on the log file." /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handle-xdg-directories"><a class="header" href="#handle-xdg-directories">Handle XDG Directories</a></h1>
<p>Handling files and directories correctly in a command-line or TUI application ensures that the
application fits seamlessly into a user’s workflow and adheres to established conventions. One of
the key conventions on Linux-based systems is the XDG Base Directory Specification.</p>
<h2 id="why-the-xdg-base-directory-specification"><a class="header" href="#why-the-xdg-base-directory-specification">Why the XDG Base Directory Specification?</a></h2>
<p>The XDG Base Directory Specification is a set of standards that define where user files should
reside, ensuring a cleaner home directory and a more organized storage convention. By adhering to
this standard, your application will store files in the expected directories, making it more
predictable and user-friendly.</p>
<h2 id="using-directories-rs-for-path-resolution"><a class="header" href="#using-directories-rs-for-path-resolution">Using <code>directories-rs</code> for Path Resolution</a></h2>
<p>The <code>directories-rs</code> library offers a Rust-friendly interface to locate common directories (like
config and data directories) based on established conventions, including the XDG Base Directory
Specification.</p>
<ol>
<li>Add <code>directories-rs</code> to your <code>Cargo.toml</code></li>
</ol>
<pre><code class="language-sh">cargo add directories
</code></pre>
<ol start="2">
<li>
<p>Use the <code>ProjectDirs</code> struct to retrieve paths based on your project’s domain and project name
and create helper functions for getting the <code>data_dir</code> and <code>config_dir</code>.</p>
</li>
<li>
<p>Allow users to specify custom locations using environment variables. This flexibility can be
crucial for users with unique directory structures or for testing.</p>
</li>
<li>
<p>A good practice is to notify the user about the location of the configuration and data
directories. An example from the template is to print out these locations when the user invokes
the <code>--version</code> command-line argument. See the section on
<a href="how-to/./clap.html">Command line argument parsing</a></p>
</li>
</ol>
<p>Here’s an example <code>get_data_dir()</code> and <code>get_config_dir()</code> functions for your reference:</p>
<pre><code class="language-rust">use std::path::PathBuf;

use anyhow::{anyhow, Context, Result};
use directories::ProjectDirs;

pub fn get_data_dir() -&gt; Result&lt;PathBuf&gt; {
  let directory = if let Ok(s) = std::env::var(&quot;RATATUI_TEMPLATE_DATA&quot;) {
    PathBuf::from(s)
  } else if let Some(proj_dirs) = ProjectDirs::from(&quot;com&quot;, &quot;kdheepak&quot;, &quot;ratatui-template&quot;) {
    proj_dirs.data_local_dir().to_path_buf()
  } else {
    return Err(anyhow!(&quot;Unable to find data directory for ratatui-template&quot;));
  };
  Ok(directory)
}

pub fn get_config_dir() -&gt; Result&lt;PathBuf&gt; {
  let directory = if let Ok(s) = std::env::var(&quot;RATATUI_TEMPLATE_CONFIG&quot;) {
    PathBuf::from(s)
  } else if let Some(proj_dirs) = ProjectDirs::from(&quot;com&quot;, &quot;kdheepak&quot;, &quot;ratatui-template&quot;) {
    proj_dirs.config_local_dir().to_path_buf()
  } else {
    return Err(anyhow!(&quot;Unable to find config directory for ratatui-template&quot;));
  };
  Ok(directory)
}</code></pre>
<p>You will want to replace <code>kdheepak</code> with your user name or company name (or any unique name for that
matter); and <code>ratatui-app</code> with the name of your CLI.</p>
<p>I own <a href="https://kdheepak.com">https://kdheepak.com</a> so I tend to use <code>com.kdheepak.ratatui-app</code> for my project directories.
That way it is unlikely that any other program will mess with the configuration files for the app I
plan on distributing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handle-cli-arguments"><a class="header" href="#handle-cli-arguments">Handle CLI arguments</a></h1>
<p>Command Line Interface (CLI) tools often require input parameters to dictate their behavior.
<a href="https://docs.rs/clap/latest/clap/"><code>clap</code></a> (Command Line Argument Parser) is a feature-rich Rust
library that facilitates the parsing of these arguments in an intuitive manner.</p>
<h2 id="defining-command-line-arguments"><a class="header" href="#defining-command-line-arguments">Defining Command Line Arguments</a></h2>
<p>In this snippet, we utilize the <code>clap</code> library to define an <code>Args</code> struct, which will be used to
capture and structure the arguments passed to the application:</p>
<pre><code class="language-rust">use clap::Parser;

#[derive(Parser, Debug)]
#[command(version = version(), about = &quot;ratatui template with crossterm and tokio&quot;)]
struct Args {
  /// App tick rate
  #[arg(short, long, default_value_t = 1000)]
  app_tick_rate: u64,
}</code></pre>
<p>Here, the Args struct defines one command-line arguments:</p>
<ul>
<li><code>app_tick_rate</code>: Dictates the application’s tick rate.</li>
</ul>
<p>This is supplied with default values, ensuring that even if the user doesn’t provide this argument,
the application can still proceed with its defaults.</p>
<h2 id="displaying-version-information"><a class="header" href="#displaying-version-information">Displaying Version Information</a></h2>
<p>One common convention in CLIs is the ability to display version information. Here, the version
information is presented as a combination of various parameters, including the Git commit hash.</p>
<p>The <code>version()</code> function, as seen in the snippet, fetches this information:</p>
<pre><code class="language-rust">pub fn version() -&gt; String {
  let author = clap::crate_authors!();

  let commit_hash = env!(&quot;RATATUI_TEMPLATE_GIT_INFO&quot;);

  // let current_exe_path = PathBuf::from(clap::crate_name!()).display().to_string();
  let config_dir_path = get_config_dir().unwrap().display().to_string();
  let data_dir_path = get_data_dir().unwrap().display().to_string();

  format!(
    &quot;\
{commit_hash}

Authors: {author}

Config directory: {config_dir_path}
Data directory: {data_dir_path}&quot;
  )
}</code></pre>
<p>This function uses the <code>get_data_dir()</code> and <code>get_config_dir()</code> from
<a href="how-to/./handle-xdg-directories.html">the section on XDG directories</a>.</p>
<p>This function also makes use of an environment variable <code>RATATUI_TEMPLATE_GIT_INFO</code> to derive the
Git commit hash. The variable can be populated during the build process by <code>build.rs</code>:</p>
<pre><code class="language-rust">  println!(&quot;cargo:rustc-env=RATATUI_TEMPLATE_GIT_INFO={}&quot;, git_describe);</code></pre>
<p>By invoking the CLI tool with the <code>--version</code> flag, users will be presented with the version
details, including the authors, commit hash, and the paths to the configuration and data
directories.</p>
<p><img src="https://user-images.githubusercontent.com/1813121/252721469-4d5ec38b-e868-46b4-b7b7-1c2c8bc496ac.png" alt="" /></p>
<p>The <code>version()</code> function’s output is just an example. You can easily adjust its content by amending
the string template code above.</p>
<p>Here’s the full <code>build.rs</code> for your reference:</p>
<pre><code class="language-rust">fn main() {
  let git_output = std::process::Command::new(&quot;git&quot;).args([&quot;rev-parse&quot;, &quot;--git-dir&quot;]).output().ok();
  let git_dir = git_output.as_ref().and_then(|output| {
    std::str::from_utf8(&amp;output.stdout).ok().and_then(|s| s.strip_suffix('\n').or_else(|| s.strip_suffix(&quot;\r\n&quot;)))
  });

  // Tell cargo to rebuild if the head or any relevant refs change.
  if let Some(git_dir) = git_dir {
    let git_path = std::path::Path::new(git_dir);
    let refs_path = git_path.join(&quot;refs&quot;);
    if git_path.join(&quot;HEAD&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/HEAD&quot;, git_dir);
    }
    if git_path.join(&quot;packed-refs&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/packed-refs&quot;, git_dir);
    }
    if refs_path.join(&quot;heads&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/refs/heads&quot;, git_dir);
    }
    if refs_path.join(&quot;tags&quot;).exists() {
      println!(&quot;cargo:rerun-if-changed={}/refs/tags&quot;, git_dir);
    }
  }

  let git_output =
    std::process::Command::new(&quot;git&quot;).args([&quot;describe&quot;, &quot;--always&quot;, &quot;--tags&quot;, &quot;--long&quot;, &quot;--dirty&quot;]).output().ok();
  let git_info = git_output.as_ref().and_then(|output| std::str::from_utf8(&amp;output.stdout).ok().map(str::trim));
  let cargo_pkg_version = env!(&quot;CARGO_PKG_VERSION&quot;);

  // Default git_describe to cargo_pkg_version
  let mut git_describe = String::from(cargo_pkg_version);

  if let Some(git_info) = git_info {
    // If the `git_info` contains `CARGO_PKG_VERSION`, we simply use `git_info` as it is.
    // Otherwise, prepend `CARGO_PKG_VERSION` to `git_info`.
    if git_info.contains(cargo_pkg_version) {
      // Remove the 'g' before the commit sha
      let git_info = &amp;git_info.replace('g', &quot;&quot;);
      git_describe = git_info.to_string();
    } else {
      git_describe = format!(&quot;v{}-{}&quot;, cargo_pkg_version, git_info);
    }
  }

  println!(&quot;cargo:rustc-env=RATATUI_TEMPLATE_GIT_INFO={}&quot;, git_describe);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-constraints-basics"><a class="header" href="#layout-constraints-basics">Layout Constraints Basics</a></h1>
<p>Here’s the “hello world” example again:</p>
<pre><code class="language-rust">pub fn render(app: &amp;mut App, f: &amp;mut Frame) {
  f.render_widget(
    Paragraph::new(&quot;Hello World!&quot;)
      .block(Block::default().borders(Borders::ALL).border_type(BorderType::Rounded)),
    f.size()
  )
}</code></pre>
<p>Here’s what the docs say for <code>f.size()</code>:</p>
<pre><code class="language-raw">ratatui::terminal::Frame

pub fn size(&amp;self) -&gt; Rect
────────────────────────────────────────────────────
Frame size, guaranteed not to change when rendering.
</code></pre>
<p><code>f.size()</code> returns a <code>Rect</code> struct. A <code>Rect</code> has the following <code>struct</code> definition:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, Default)]
pub struct Rect {
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
}</code></pre>
<p>That is to say, they have a <code>x</code> and <code>y</code> positional coordinates and <code>width</code> and <code>height</code> dimensional
values.</p>
<p>The coordinate system in <code>ratatui</code> (and in terminals in general) starts at the top left of the
terminal or container widget. This point represents <code>(0,0)</code>.</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="216" height="160">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="216" height="160"></rect>
  <path d="M 8,0 A 16,16 0,0,0 8,16" class="nofill"></path>
  <text x="18" y="12" >0,</text>
  <text x="42" y="12" >0</text>
  <path d="M 56,0 A 16,16 0,0,1 56,16" class="nofill"></path>
  <text x="202" y="12" >x</text>
  <text x="26" y="140" >y</text>
  <g>
    <line x1="72" y1="8" x2="184" y2="8" class="solid"></line>
    <polygon points="184,4 192,8 184,12" class="filled"></polygon>
  </g>
  <g>
    <line x1="28" y1="32" x2="28" y2="100" class="solid"></line>
    <polygon points="24,100 32,100 28,112" class="filled"></polygon>
  </g>
</svg></pre>
<p>Here’s the “hello world” example from above rendered:</p>
<pre><code class="language-raw">╭───────────────────────────────────╮
│Hello World!                       │
│                                   │
│                                   │
╰───────────────────────────────────╯
</code></pre>
<p>What if hypothetically we wanted to render this instead:</p>
<pre><code class="language-raw">╭────────────────╮╭─────────────────╮
│Hello World!    ││Hello World!     │
│                ││                 │
│                ││                 │
╰────────────────╯╰─────────────────╯
</code></pre>
<p>We <em>could</em> integer divide the <code>width</code> by 2, account of the borders calculate the <code>x</code> position for
the second paragraph but that is cumbersome and error prone.</p>
<p>Now, that’s where layouts come in.</p>
<pre><code class="language-rust">let rects = Layout::default()
    .direction(Direction::Horizontal)
    .constraints(
        [
            Constraint::Percentage(50),
            Constraint::Percentage(50),
        ]
        .as_ref(),
    )
    .split(f.size());</code></pre>
<p>Here we created a layout and added two “constraints”. The constraints determine the size of the
resulting <code>Rect</code>s. Calling <code>split</code> on a <code>Layout</code> splits the layout based on the constraints.</p>
<p>That is, <code>rects</code> behaves as a <code>Vec&lt;Rect&gt;</code>, whose length always matches the number of constraints.</p>
<p>So for the example above, we might want to do something like this:</p>
<pre><code class="language-rust">pub fn render(app: &amp;mut App, f: &amp;mut Frame) {
  let chunks = Layout::default()
    .direction(Direction::Horizontal)
    .constraints(
        [
            Constraint::Percentage(50),
            Constraint::Percentage(50),
        ]
        .as_ref(),
    )
    .split(f.size());
  f.render_widget(
    Paragraph::new(&quot;Hello World!&quot;)
      .block(Block::default().borders(Borders::ALL).border_type(BorderType::Rounded)),
    chunks[0]
  )
  f.render_widget(
    Paragraph::new(&quot;Hello World!&quot;)
      .block(Block::default().borders(Borders::ALL).border_type(BorderType::Rounded)),
    chunks[1]
  )
}</code></pre>
<p>Notice that we used the first <code>chunk</code> for the first <code>Paragraph</code> and the second <code>chunk</code> for the
second <code>Paragraph</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>This section has some frequently asked questions about <code>ratatui</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-am-i-getting-duplicate-key-events-on-windows"><a class="header" href="#why-am-i-getting-duplicate-key-events-on-windows">Why am I getting duplicate key events on Windows?</a></h1>
<p>A lot of examples out there in the wild might use the following code for sending key presses:</p>
<pre><code class="language-rust">  CrosstermEvent::Key(e) =&gt; tx.send(Event::Key(e)),</code></pre>
<p>However, on Windows, when using <code>Crossterm</code>, this will send the same <code>Event::Key(e)</code> twice; one for
when you press the key, i.e. <code>KeyEventKind::Press</code> and one for when you release the key, i.e.
<code>KeyEventKind::Release</code>. On <code>MacOS</code> and <code>Linux</code> only <code>KeyEventKind::Press</code> kinds of <code>key</code> event is
generated.</p>
<p>To make the code work as expected across all platforms, you can do this instead:</p>
<pre><code class="language-rust">  CrosstermEvent::Key(key) =&gt; {
    if key.kind == KeyEventKind::Press {
      event_tx.send(Event::Key(key)).unwrap();
    }
  },</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="when-should-i-use-tokio-and-asyncawait"><a class="header" href="#when-should-i-use-tokio-and-asyncawait">When should I use <code>tokio</code> and <code>async</code>/<code>await</code>?</a></h2>
<p><code>ratatui</code> isn’t a native <code>async</code> library. So is it beneficial to use <code>tokio</code> or <code>async</code>/<code>await</code>?</p>
<p>And as a user, there really is only one point of interface with the <code>ratatui</code> library and that’s the
<code>terminal.draw(|f| ui(f))</code> functionality, because the rendering of widgets happens in <code>ui(f)</code>.
Everything else in your code is your own to do as you wish.</p>
<p>Should <code>terminal.draw(|f| ui(f))</code> be <code>async</code>? Possibly. Rendering to the terminal buffer is
relatively fast, especially using the double buffer technique that only renders diffs that <code>ratatui</code>
uses.</p>
<p>Can we make it <code>async</code> ourselves? Yes, we can. That’s covered in the material in this documentation.</p>
<p>The only other part related to <code>ratatui</code> that is beneficial to being <code>async</code> is reading the key
event inputs from <code>stdin</code>, and that can be made <code>async</code> with <code>crossterm</code>’s event-stream.</p>
<p>So the real question is what other parts of your app require <code>async</code> or benefit from being <code>async</code>?
If the answer is not much, maybe it is simpler to not use <code>async</code> and avoiding <code>tokio</code>.</p>
<p>Another way to think about it is, do you think your app would work better with 1 thread like this?</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="136" height="224">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="136" height="224"></rect>
  <text x="18" y="28" >Get</text>
  <text x="50" y="28" >Key</text>
  <text x="82" y="28" >Event</text>
  <text x="18" y="108" >Update</text>
  <text x="74" y="108" >State</text>
  <text x="42" y="188" >Render</text>
  <g>
    <path d="M 16,8 A 4,4 0,0,0 12,12" class="nofill"></path>
    <line x1="12" y1="12" x2="12" y2="36" class="solid"></line>
    <line x1="16" y1="8" x2="120" y2="8" class="solid"></line>
    <path d="M 120,8 A 4,4 0,0,1 124,12" class="nofill"></path>
    <line x1="124" y1="12" x2="124" y2="36" class="solid"></line>
    <path d="M 12,36 A 4,4 0,0,0 16,40" class="nofill"></path>
    <line x1="16" y1="40" x2="120" y2="40" class="solid"></line>
    <line x1="60" y1="40" x2="60" y2="84" class="solid"></line>
    <path d="M 124,36 A 4,4 0,0,1 120,40" class="nofill"></path>
    <polygon points="56,84 64,84 60,96" class="filled"></polygon>
  </g>
  <g>
    <path d="M 16,88 A 4,4 0,0,0 12,92" class="nofill"></path>
    <line x1="12" y1="92" x2="12" y2="116" class="solid"></line>
    <line x1="16" y1="88" x2="56" y2="88" class="solid"></line>
    <path d="M 12,116 A 4,4 0,0,0 16,120" class="nofill"></path>
    <line x1="16" y1="120" x2="112" y2="120" class="solid"></line>
    <line x1="60" y1="120" x2="60" y2="164" class="solid"></line>
    <polygon points="56,164 64,164 60,176" class="filled"></polygon>
    <line x1="64" y1="88" x2="112" y2="88" class="solid"></line>
    <path d="M 112,88 A 4,4 0,0,1 116,92" class="nofill"></path>
    <line x1="116" y1="92" x2="116" y2="116" class="solid"></line>
    <path d="M 116,116 A 4,4 0,0,1 112,120" class="nofill"></path>
  </g>
  <g>
    <path d="M 32,168 A 4,4 0,0,0 28,172" class="nofill"></path>
    <line x1="28" y1="172" x2="28" y2="196" class="solid"></line>
    <line x1="32" y1="168" x2="56" y2="168" class="solid"></line>
    <path d="M 28,196 A 4,4 0,0,0 32,200" class="nofill"></path>
    <line x1="32" y1="200" x2="96" y2="200" class="solid"></line>
    <line x1="64" y1="168" x2="96" y2="168" class="solid"></line>
    <path d="M 96,168 A 4,4 0,0,1 100,172" class="nofill"></path>
    <line x1="100" y1="172" x2="100" y2="196" class="solid"></line>
    <path d="M 100,196 A 4,4 0,0,1 96,200" class="nofill"></path>
  </g>
</svg></pre>
<p>Or would it work with 3 threads / <code>tokio</code> tasks like this:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="664" height="352">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="664" height="352"></rect>
  <text x="34" y="12" >Render</text>
  <text x="90" y="12" >Thread</text>
  <line x1="196" y1="0" x2="196" y2="336" class="broken"></line>
  <line x1="476" y1="0" x2="476" y2="336" class="broken"></line>
  <text x="274" y="60" >Get</text>
  <text x="306" y="60" >Key</text>
  <text x="338" y="60" >Event</text>
  <text x="258" y="124" >Map</text>
  <text x="290" y="124" >Event</text>
  <text x="338" y="124" >to</text>
  <text x="362" y="124" >Action</text>
  <text x="234" y="188" >Send</text>
  <text x="274" y="188" >Action</text>
  <text x="330" y="188" >on</text>
  <text x="354" y="188" >action</text>
  <line x1="400" y1="192" x2="408" y2="192" class="solid"></line>
  <text x="410" y="188" >tx</text>
  <text x="538" y="188" >Recv</text>
  <text x="578" y="188" >Action</text>
  <text x="18" y="252" >Recv</text>
  <text x="58" y="252" >on</text>
  <text x="82" y="252" >render</text>
  <line x1="128" y1="256" x2="136" y2="256" class="solid"></line>
  <text x="138" y="252" >rx</text>
  <line x1="200" y1="248" x2="472" y2="248" class="solid"></line>
  <text x="514" y="252" >Dispatch</text>
  <text x="586" y="252" >Action</text>
  <text x="18" y="316" >Render</text>
  <text x="74" y="316" >Component</text>
  <text x="530" y="316" >Update</text>
  <text x="586" y="316" >State</text>
  <text x="274" y="12" >Event</text>
  <text x="322" y="12" >Thread</text>
  <text x="522" y="12" >Main</text>
  <text x="562" y="12" >Thread</text>
  <g>
    <path d="M 256,40 A 4,4 0,0,0 252,44" class="nofill"></path>
    <line x1="252" y1="44" x2="252" y2="68" class="solid"></line>
    <line x1="256" y1="40" x2="400" y2="40" class="solid"></line>
    <path d="M 400,40 A 4,4 0,0,1 404,44" class="nofill"></path>
    <line x1="404" y1="44" x2="404" y2="68" class="solid"></line>
    <path d="M 252,68 A 4,4 0,0,0 256,72" class="nofill"></path>
    <line x1="256" y1="72" x2="400" y2="72" class="solid"></line>
    <line x1="324" y1="72" x2="324" y2="100" class="solid"></line>
    <path d="M 404,68 A 4,4 0,0,1 400,72" class="nofill"></path>
    <polygon points="320,100 328,100 324,112" class="filled"></polygon>
  </g>
  <g>
    <path d="M 248,104 A 4,4 0,0,0 244,108" class="nofill"></path>
    <line x1="244" y1="108" x2="244" y2="132" class="solid"></line>
    <line x1="248" y1="104" x2="320" y2="104" class="solid"></line>
    <path d="M 244,132 A 4,4 0,0,0 248,136" class="nofill"></path>
    <line x1="248" y1="136" x2="416" y2="136" class="solid"></line>
    <line x1="324" y1="136" x2="324" y2="164" class="solid"></line>
    <polygon points="320,164 328,164 324,176" class="filled"></polygon>
    <line x1="328" y1="104" x2="416" y2="104" class="solid"></line>
    <path d="M 416,104 A 4,4 0,0,1 420,108" class="nofill"></path>
    <line x1="420" y1="108" x2="420" y2="132" class="solid"></line>
    <path d="M 420,132 A 4,4 0,0,1 416,136" class="nofill"></path>
  </g>
  <g>
    <path d="M 224,168 A 4,4 0,0,0 220,172" class="nofill"></path>
    <line x1="220" y1="172" x2="220" y2="196" class="solid"></line>
    <line x1="224" y1="168" x2="320" y2="168" class="solid"></line>
    <path d="M 220,196 A 4,4 0,0,0 224,200" class="nofill"></path>
    <line x1="224" y1="200" x2="440" y2="200" class="solid"></line>
    <line x1="328" y1="168" x2="440" y2="168" class="solid"></line>
    <path d="M 440,168 A 4,4 0,0,1 444,172" class="nofill"></path>
    <line x1="444" y1="172" x2="444" y2="196" class="solid"></line>
    <line x1="444" y1="184" x2="472" y2="184" class="solid"></line>
    <path d="M 444,196 A 4,4 0,0,1 440,200" class="nofill"></path>
  </g>
  <g>
    <path d="M 528,168 A 4,4 0,0,0 524,172" class="nofill"></path>
    <line x1="524" y1="172" x2="524" y2="196" class="solid"></line>
    <line x1="528" y1="168" x2="632" y2="168" class="solid"></line>
    <path d="M 632,168 A 4,4 0,0,1 636,172" class="nofill"></path>
    <line x1="636" y1="172" x2="636" y2="196" class="solid"></line>
    <path d="M 524,196 A 4,4 0,0,0 528,200" class="nofill"></path>
    <line x1="528" y1="200" x2="632" y2="200" class="solid"></line>
    <line x1="572" y1="200" x2="572" y2="228" class="solid"></line>
    <path d="M 636,196 A 4,4 0,0,1 632,200" class="nofill"></path>
    <polygon points="568,228 576,228 572,240" class="filled"></polygon>
  </g>
  <g>
    <line x1="480" y1="184" x2="512" y2="184" class="solid"></line>
    <polygon points="512,180 520,184 512,188" class="filled"></polygon>
  </g>
  <g>
    <path d="M 8,232 A 4,4 0,0,0 4,236" class="nofill"></path>
    <line x1="4" y1="236" x2="4" y2="260" class="solid"></line>
    <line x1="8" y1="232" x2="160" y2="232" class="solid"></line>
    <path d="M 160,232 A 4,4 0,0,1 164,236" class="nofill"></path>
    <line x1="164" y1="236" x2="164" y2="260" class="solid"></line>
    <path d="M 4,260 A 4,4 0,0,0 8,264" class="nofill"></path>
    <line x1="8" y1="264" x2="160" y2="264" class="solid"></line>
    <line x1="76" y1="264" x2="76" y2="292" class="solid"></line>
    <path d="M 164,260 A 4,4 0,0,1 160,264" class="nofill"></path>
    <polygon points="72,292 80,292 76,304" class="filled"></polygon>
  </g>
  <g>
    <path d="M 504,232 A 4,4 0,0,0 500,236" class="nofill"></path>
    <line x1="500" y1="236" x2="500" y2="260" class="solid"></line>
    <line x1="504" y1="232" x2="568" y2="232" class="solid"></line>
    <line x1="480" y1="248" x2="500" y2="248" class="solid"></line>
    <path d="M 500,260 A 4,4 0,0,0 504,264" class="nofill"></path>
    <line x1="504" y1="264" x2="640" y2="264" class="solid"></line>
    <line x1="572" y1="264" x2="572" y2="292" class="solid"></line>
    <polygon points="568,292 576,292 572,304" class="filled"></polygon>
    <line x1="576" y1="232" x2="640" y2="232" class="solid"></line>
    <path d="M 640,232 A 4,4 0,0,1 644,236" class="nofill"></path>
    <line x1="644" y1="236" x2="644" y2="260" class="solid"></line>
    <path d="M 644,260 A 4,4 0,0,1 640,264" class="nofill"></path>
  </g>
  <g>
    <polygon points="176,244 168,248 176,252" class="filled"></polygon>
    <line x1="176" y1="248" x2="192" y2="248" class="solid"></line>
  </g>
  <g>
    <path d="M 8,296 A 4,4 0,0,0 4,300" class="nofill"></path>
    <line x1="4" y1="300" x2="4" y2="324" class="solid"></line>
    <line x1="8" y1="296" x2="72" y2="296" class="solid"></line>
    <path d="M 4,324 A 4,4 0,0,0 8,328" class="nofill"></path>
    <line x1="8" y1="328" x2="152" y2="328" class="solid"></line>
    <line x1="80" y1="296" x2="152" y2="296" class="solid"></line>
    <path d="M 152,296 A 4,4 0,0,1 156,300" class="nofill"></path>
    <line x1="156" y1="300" x2="156" y2="324" class="solid"></line>
    <path d="M 156,324 A 4,4 0,0,1 152,328" class="nofill"></path>
  </g>
  <g>
    <path d="M 504,296 A 4,4 0,0,0 500,300" class="nofill"></path>
    <line x1="500" y1="300" x2="500" y2="324" class="solid"></line>
    <line x1="504" y1="296" x2="568" y2="296" class="solid"></line>
    <path d="M 500,324 A 4,4 0,0,0 504,328" class="nofill"></path>
    <line x1="504" y1="328" x2="648" y2="328" class="solid"></line>
    <line x1="576" y1="296" x2="648" y2="296" class="solid"></line>
    <path d="M 648,296 A 4,4 0,0,1 652,300" class="nofill"></path>
    <line x1="652" y1="300" x2="652" y2="324" class="solid"></line>
    <path d="M 652,324 A 4,4 0,0,1 648,328" class="nofill"></path>
  </g>
</svg></pre>
<p>The former be done without <code>async</code> and the latter is the approach described in this documentation
with <code>tokio</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ratatui-book-1"><a class="header" href="#ratatui-book-1">Ratatui Book</a></h1>
<p>The <a href="https://github.com/ratatui-org/ratatui-book">ratatui-book</a> is written in
<a href="https://rust-lang.github.io/mdBook/"><code>mdbook</code></a>.</p>
<p>The book is built as HTML pages as part of a
<a href="https://github.com/ratatui-org/ratatui-book/blob/main/.github/workflows/mdbook.yml">GitHub Action</a>
and is available to view at <a href="https://ratatui-org.github.io/ratatui-book/">https://ratatui-org.github.io/ratatui-book/</a>.</p>
<p>Feel free to make contributions if you’d like to improve the documentation.</p>
<p>If you want to set up your local environment, you can run the following:</p>
<pre><code class="language-bash">cargo install mdbook --version 0.4.30
cargo install mdbook-admonish --version 1.9.0
cargo install mdbook-svgbob2 --version 0.3.0
cargo install mdbook-linkcheck --version 0.7.7
cargo install mdbook-mermaid --version 0.12.6
cargo install mdbook-emojicodes --version 0.2.2
</code></pre>
<p>These plugins allow additional features.</p>
<h3 id="mdbook-admonish"><a class="header" href="#mdbook-admonish"><code>mdbook-admonish</code></a></h3>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">```admonish note
This is a note
```

```admonish tip
This is a tip
```

```admonish warning
This is a warning
```

```admonish info
This is a info
```
</code></pre>
<p>will render as the following:</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-note"></a></p>
</div>
<div>
<p>This is a note</p>
</div>
</div>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-tip"></a></p>
</div>
<div>
<p>This is a tip</p>
</div>
</div>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-warning"></a></p>
</div>
<div>
<p>This is a warning</p>
</div>
</div>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="developer-guide/book.html#admonition-info"></a></p>
</div>
<div>
<p>This is a info</p>
</div>
</div>
<h3 id="mdbook-mermaid"><a class="header" href="#mdbook-mermaid"><code>mdbook-mermaid</code></a></h3>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">```mermaid
graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
```
</code></pre>
<p>will render as the following:</p>
<pre class="mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</pre>
<h3 id="mdbook-svgbob2"><a class="header" href="#mdbook-svgbob2"><code>mdbook-svgbob2</code></a></h3>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">```svgbob
       .---.
      /-o-/--
   .-/ / /-&gt;
  ( *  \/
   '-.  \
      \ /
       '
```
</code></pre>
<p>will render as the following:</p>
<pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="112" height="128">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="112" height="128"></rect>
  <circle cx="68" cy="24" r="3" class="nofill"></circle>
  <line x1="72" y1="24" x2="104" y2="24" class="solid"></line>
  <circle cx="36" cy="56" r="3" class="filled"></circle>
  <g>
    <path d="M 64,8 A 8,8 0,0,0 58,12" class="nofill"></path>
    <line x1="58" y1="12" x2="38" y2="52" class="solid"></line>
    <line x1="64" y1="8" x2="88" y2="8" class="solid"></line>
    <path d="M 88,8 A 3,3 0,0,1 90,12" class="nofill"></path>
    <line x1="90" y1="12" x2="64" y2="64" class="solid"></line>
    <line x1="52" y1="24" x2="64" y2="24" class="solid"></line>
    <line x1="76" y1="40" x2="88" y2="40" class="solid"></line>
    <polygon points="88,36 96,40 88,44" class="filled"></polygon>
    <line x1="66" y1="28" x2="56" y2="48" class="solid"></line>
    <line x1="56" y1="48" x2="72" y2="80" class="solid"></line>
    <path d="M 32,40 A 8,8 0,0,0 26,44" class="nofill"></path>
    <line x1="26" y1="44" x2="24" y2="48" class="solid"></line>
    <line x1="32" y1="40" x2="44" y2="40" class="solid"></line>
    <path d="M 24,48 A 16,16 0,0,0 24,64" class="nofill"></path>
    <line x1="24" y1="64" x2="26" y2="68" class="solid"></line>
    <path d="M 26,68 A 8,8 0,0,0 32,72" class="nofill"></path>
    <line x1="32" y1="72" x2="40" y2="72" class="solid"></line>
    <path d="M 40,72 A 8,8 0,0,1 46,76" class="nofill"></path>
    <line x1="46" y1="76" x2="60" y2="104" class="solid"></line>
    <line x1="72" y1="80" x2="60" y2="104" class="solid"></line>
  </g>
</svg></pre>
<h3 id="mdbook-emojicodes"><a class="header" href="#mdbook-emojicodes"><code>mdbook-emojicodes</code></a></h3>
<p>The following raw markdown:</p>
<pre><code class="language-markdown">I love cats 🐱 and dogs 🐶, I have two, one's gray, like a raccoon 🦝, and the other
one is black, like the night 🌃.
</code></pre>
<p>will render as the following:</p>
<p>I love cats 🐱 and dogs 🐶, I have two, one’s gray, like a raccoon 🦝, and the other
one is black, like the night 🌃.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
